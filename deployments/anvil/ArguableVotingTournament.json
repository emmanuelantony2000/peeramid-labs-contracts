{
  "address": "0x7fD8b6dABFB3192Ff425399a89d56895f67731E0",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "initializer",
          "type": "address"
        },
        {
          "internalType": "bytes4",
          "name": "initializerSelector",
          "type": "bytes4"
        },
        {
          "internalType": "bytes32",
          "name": "_distributionName",
          "type": "bytes32"
        },
        {
          "components": [
            {
              "internalType": "uint64",
              "name": "major",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "minor",
              "type": "uint64"
            },
            {
              "internalType": "uint128",
              "name": "patch",
              "type": "uint128"
            }
          ],
          "internalType": "struct LibSemver.Version",
          "name": "version",
          "type": "tuple"
        },
        {
          "internalType": "address",
          "name": "loupeFacet",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "inspectorFacet",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "RankifyMainFacet",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "RankifyReqsFacet",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "RankifyGMFacet",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "RankifyOwnerFacet",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "OwnershipFacetAddr",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "codeId",
          "type": "bytes32"
        }
      ],
      "name": "CodeNotFoundInIndex",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ERC1167FailedCreateClone",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "distributor",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address[]",
          "name": "instances",
          "type": "address[]"
        }
      ],
      "name": "Distributed",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "contractURI",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "get",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "",
          "type": "address[]"
        },
        {
          "internalType": "bytes32",
          "name": "name",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "version",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "instantiate",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "instances",
          "type": "address[]"
        },
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x8ebd1ec637c17096752f2cfc59671ffdc30b78f2ab59233a498fc0fe2ac36e29",
  "receipt": {
    "to": null,
    "from": "0x6Cf8d74C7875de8C2FfB09228F4bf2A21b25e583",
    "contractAddress": "0x7fD8b6dABFB3192Ff425399a89d56895f67731E0",
    "transactionIndex": 0,
    "gasUsed": "4855004",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000800000080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000001000001000040040800000000000000000000020000000000000000008800000000000000000000000000000000400020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x2f859b63f3900d154fbce9fd343dbe498a6bdee16b1e60c8b446ba79897322f1",
    "transactionHash": "0x8ebd1ec637c17096752f2cfc59671ffdc30b78f2ab59233a498fc0fe2ac36e29",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 6137752,
        "transactionHash": "0x8ebd1ec637c17096752f2cfc59671ffdc30b78f2ab59233a498fc0fe2ac36e29",
        "address": "0xa45d7B62332CfbD61f75398AF24ea23d3F39b7f0",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000007fd8b6dabfb3192ff425399a89d56895f67731e0"
        ],
        "data": "0x",
        "logIndex": 0,
        "blockHash": "0x2f859b63f3900d154fbce9fd343dbe498a6bdee16b1e60c8b446ba79897322f1"
      },
      {
        "transactionIndex": 0,
        "blockNumber": 6137752,
        "transactionHash": "0x8ebd1ec637c17096752f2cfc59671ffdc30b78f2ab59233a498fc0fe2ac36e29",
        "address": "0xa45d7B62332CfbD61f75398AF24ea23d3F39b7f0",
        "topics": [
          "0x8faa70878671ccd212d20771b795c50af8fd3ff6cf27f4bde57e5d4de0aeb673"
        ],
        "data": "0x000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000200000000000000000000000000e00f833549c4f053b67bf9f0985f21ae8f5548c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000011f931c1c000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
        "logIndex": 1,
        "blockHash": "0x2f859b63f3900d154fbce9fd343dbe498a6bdee16b1e60c8b446ba79897322f1"
      }
    ],
    "blockNumber": 6137752,
    "cumulativeGasUsed": "4855004",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x9984e431bbf58e674667BA909e4114C961b46578",
    "0x00000000",
    "0x4172677561626c65566f74696e67546f75726e616d656e740000000000000000",
    {
      "major": 1,
      "minor": 0,
      "patch": 0
    },
    "0x2692a6B25B1cE5f5D1c0c61F5585636b0E5E4Abb",
    "0x941D54F8DbFe25D1CAeb440b72C489AAc4Bb0450",
    "0x42ac3cd25A2dD958d933c84Fb9A455b5f35117Df",
    "0x842e90B6aa34Eb9fa11C064bBe02455e688350a3",
    "0xCc31ff75aa532248d546dAF712CB2E306A70BEc2",
    "0x022F5e6CD774DE0505977A5421c8f93374c3BC34",
    "0x5431F19cC79905E0cA07C33239A98AE9A1e1d79a"
  ],
  "numDeployments": 1,
  "solcInputHash": "8b178e5db390f3cab8ab670750551215",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initializer\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"initializerSelector\",\"type\":\"bytes4\"},{\"internalType\":\"bytes32\",\"name\":\"_distributionName\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"major\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"minor\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"patch\",\"type\":\"uint128\"}],\"internalType\":\"struct LibSemver.Version\",\"name\":\"version\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"loupeFacet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inspectorFacet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"RankifyMainFacet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"RankifyReqsFacet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"RankifyGMFacet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"RankifyOwnerFacet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"OwnershipFacetAddr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"codeId\",\"type\":\"bytes32\"}],\"name\":\"CodeNotFoundInIndex\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1167FailedCreateClone\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"distributor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"instances\",\"type\":\"address[]\"}],\"name\":\"Distributed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"instantiate\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"instances\",\"type\":\"address[]\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"Peeramid Labs, 2024\",\"details\":\"It is expected to be used ONLY by the Distributor contract.\",\"errors\":{\"ERC1167FailedCreateClone()\":[{\"details\":\"A clone instance deployment failed.\"}]},\"events\":{\"Distributed(address,address[])\":{\"params\":{\"distributor\":\"The address of the entity that performed the distribution.\",\"instances\":\"An array of addresses that were produced.\"}}},\"kind\":\"dev\",\"methods\":{\"constructor\":{\"details\":\"Constructor for the ArguableVotingTournament contract. Note Initializer function will be added as a regular facet to the Diamond Proxy, Since it is expected that initialization is done by distributor contract, the initializer will not be run, hence it is up for distributor to remove this facet upon succesfull initialization.\"},\"get()\":{\"returns\":{\"_0\":\"An array of addresses that are used for instantiation.\",\"name\":\"The name of the distribution.\",\"version\":\"The version of the distribution.\"}},\"instantiate(bytes)\":{\"details\":\"see Ethereum Distribution System IDistribute for interface specification.\",\"returns\":{\"_1\":\"distributionName: bytes32 encoded name to be used in EIP712 signing flow\",\"_2\":\"distributionVersion: uint256 encoded distribution version. Can be parsed to eip712 signature with EDS LibSemver\",\"instances\":\"Array[9]: [diamond proxy, 8x diamond facets..]\"}}},\"title\":\"ArguableVotingTournament Distribution\",\"version\":1},\"userdoc\":{\"events\":{\"Distributed(address,address[])\":{\"notice\":\"Emitted when a distribution occurs.\"}},\"kind\":\"user\",\"methods\":{\"get()\":{\"notice\":\"Retrieves the current distribution sources.\"}},\"notice\":\"This contract implements a diamond distribution for Ethereum Distribution System. It is reponsible to create new instance of ArguableVotingTournament.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/distributions/ArguableVotingTournament.sol\":\"ArguableVotingTournament\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":2000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Storage of the initializable contract.\\n     *\\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\\n     * when using with upgradeable contracts.\\n     *\\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\\n     */\\n    struct InitializableStorage {\\n        /**\\n         * @dev Indicates that the contract has been initialized.\\n         */\\n        uint64 _initialized;\\n        /**\\n         * @dev Indicates that the contract is in the process of being initialized.\\n         */\\n        bool _initializing;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Initializable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\\n\\n    /**\\n     * @dev The contract is already initialized.\\n     */\\n    error InvalidInitialization();\\n\\n    /**\\n     * @dev The contract is not initializing.\\n     */\\n    error NotInitializing();\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint64 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\\n     * production.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        // Cache values to avoid duplicated sloads\\n        bool isTopLevelCall = !$._initializing;\\n        uint64 initialized = $._initialized;\\n\\n        // Allowed calls:\\n        // - initialSetup: the contract is not in the initializing state and no previous version was\\n        //                 initialized\\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\\n        //                 current contract is just being deployed\\n        bool initialSetup = initialized == 0 && isTopLevelCall;\\n        bool construction = initialized == 1 && address(this).code.length == 0;\\n\\n        if (!initialSetup && !construction) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = 1;\\n        if (isTopLevelCall) {\\n            $._initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            $._initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint64 version) {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing || $._initialized >= version) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = version;\\n        $._initializing = true;\\n        _;\\n        $._initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        _checkInitializing();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\\n     */\\n    function _checkInitializing() internal view virtual {\\n        if (!_isInitializing()) {\\n            revert NotInitializing();\\n        }\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing) {\\n            revert InvalidInitialization();\\n        }\\n        if ($._initialized != type(uint64).max) {\\n            $._initialized = type(uint64).max;\\n            emit Initialized(type(uint64).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint64) {\\n        return _getInitializableStorage()._initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _getInitializableStorage()._initializing;\\n    }\\n\\n    /**\\n     * @dev Returns a pointer to the storage namespace.\\n     */\\n    // solhint-disable-next-line var-name-mixedcase\\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\\n        assembly {\\n            $.slot := INITIALIZABLE_STORAGE\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x631188737069917d2f909d29ce62c4d48611d326686ba6683e26b72a23bfac0b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xff6d0bb2e285473e5311d9d3caacb525ae3538a80758c10649a4d61029b017bb\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1155.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC1155} from \\\"../token/ERC1155/IERC1155.sol\\\";\\n\",\"keccak256\":\"0x1528f3ef49ef2750b428564df007feb2d5c7a792bf79c6d125409c96322a4c00\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC1271.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1271.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC1271 standard signature validation method for\\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\n */\\ninterface IERC1271 {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param hash      Hash of the data to be signed\\n     * @param signature Signature byte array associated with _data\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\",\"keccak256\":\"0x85a45f3f10014a0f8be41157a32b6a5f905753ea64a4b64e29fc12b7deeecf39\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../token/ERC20/IERC20.sol\\\";\\n\",\"keccak256\":\"0xce41876e78d1badc0512229b4d14e4daf83bc1003d7f83978d18e0e56f965b9c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard ERC20 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\\n */\\ninterface IERC20Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC20InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC20InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender`\\u2019s `allowance`. Used in transfers.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC20InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC20InvalidSpender(address spender);\\n}\\n\\n/**\\n * @dev Standard ERC721 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\\n */\\ninterface IERC721Errors {\\n    /**\\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\\n     * Used in balance queries.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721InvalidOwner(address owner);\\n\\n    /**\\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721NonexistentToken(uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param tokenId Identifier number of a token.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC721InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC721InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC721InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC721InvalidOperator(address operator);\\n}\\n\\n/**\\n * @dev Standard ERC1155 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\\n */\\ninterface IERC1155Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC1155InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC1155InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC1155MissingApprovalForAll(address operator, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC1155InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC1155InvalidOperator(address operator);\\n\\n    /**\\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\\n     * Used in batch transfers.\\n     * @param idsLength Length of the array of token identifiers\\n     * @param valuesLength Length of the array of token amounts\\n     */\\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\\n}\\n\",\"keccak256\":\"0x60c65f701957fdd6faea1acb0bb45825791d473693ed9ecb34726fdfaa849dd7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/Clones.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n */\\nlibrary Clones {\\n    /**\\n     * @dev A clone instance deployment failed.\\n     */\\n    error ERC1167FailedCreateClone();\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(0, 0x09, 0x37)\\n        }\\n        if (instance == address(0)) {\\n            revert ERC1167FailedCreateClone();\\n        }\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(0, 0x09, 0x37, salt)\\n        }\\n        if (instance == address(0)) {\\n            revert ERC1167FailedCreateClone();\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt\\n    ) internal view returns (address predicted) {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\",\"keccak256\":\"0xd18408af8a91bedb3d56343eeb9b30eb852e6dea93a5e2d5c6db9ca4cb905155\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/ERC1155.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC1155} from \\\"./IERC1155.sol\\\";\\nimport {IERC1155Receiver} from \\\"./IERC1155Receiver.sol\\\";\\nimport {IERC1155MetadataURI} from \\\"./extensions/IERC1155MetadataURI.sol\\\";\\nimport {Context} from \\\"../../utils/Context.sol\\\";\\nimport {IERC165, ERC165} from \\\"../../utils/introspection/ERC165.sol\\\";\\nimport {Arrays} from \\\"../../utils/Arrays.sol\\\";\\nimport {IERC1155Errors} from \\\"../../interfaces/draft-IERC6093.sol\\\";\\n\\n/**\\n * @dev Implementation of the basic standard multi-token.\\n * See https://eips.ethereum.org/EIPS/eip-1155\\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\\n */\\nabstract contract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI, IERC1155Errors {\\n    using Arrays for uint256[];\\n    using Arrays for address[];\\n\\n    mapping(uint256 id => mapping(address account => uint256)) private _balances;\\n\\n    mapping(address account => mapping(address operator => bool)) private _operatorApprovals;\\n\\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\n    string private _uri;\\n\\n    /**\\n     * @dev See {_setURI}.\\n     */\\n    constructor(string memory uri_) {\\n        _setURI(uri_);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC1155).interfaceId ||\\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155MetadataURI-uri}.\\n     *\\n     * This implementation returns the same URI for *all* token types. It relies\\n     * on the token type ID substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * Clients calling this function must replace the `\\\\{id\\\\}` substring with the\\n     * actual token type ID.\\n     */\\n    function uri(uint256 /* id */) public view virtual returns (string memory) {\\n        return _uri;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOf}.\\n     */\\n    function balanceOf(address account, uint256 id) public view virtual returns (uint256) {\\n        return _balances[id][account];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOfBatch}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] memory accounts,\\n        uint256[] memory ids\\n    ) public view virtual returns (uint256[] memory) {\\n        if (accounts.length != ids.length) {\\n            revert ERC1155InvalidArrayLength(ids.length, accounts.length);\\n        }\\n\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\n            batchBalances[i] = balanceOf(accounts.unsafeMemoryAccess(i), ids.unsafeMemoryAccess(i));\\n        }\\n\\n        return batchBalances;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) public view virtual returns (bool) {\\n        return _operatorApprovals[account][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) public virtual {\\n        address sender = _msgSender();\\n        if (from != sender && !isApprovedForAll(from, sender)) {\\n            revert ERC1155MissingApprovalForAll(sender, from);\\n        }\\n        _safeTransferFrom(from, to, id, value, data);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory values,\\n        bytes memory data\\n    ) public virtual {\\n        address sender = _msgSender();\\n        if (from != sender && !isApprovedForAll(from, sender)) {\\n            revert ERC1155MissingApprovalForAll(sender, from);\\n        }\\n        _safeBatchTransferFrom(from, to, ids, values, data);\\n    }\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`. Will mint (or burn) if `from`\\n     * (or `to`) is the zero address.\\n     *\\n     * Emits a {TransferSingle} event if the arrays contain one element, and {TransferBatch} otherwise.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement either {IERC1155Receiver-onERC1155Received}\\n     *   or {IERC1155Receiver-onERC1155BatchReceived} and return the acceptance magic value.\\n     * - `ids` and `values` must have the same length.\\n     *\\n     * NOTE: The ERC-1155 acceptance check is not performed in this function. See {_updateWithAcceptanceCheck} instead.\\n     */\\n    function _update(address from, address to, uint256[] memory ids, uint256[] memory values) internal virtual {\\n        if (ids.length != values.length) {\\n            revert ERC1155InvalidArrayLength(ids.length, values.length);\\n        }\\n\\n        address operator = _msgSender();\\n\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            uint256 id = ids.unsafeMemoryAccess(i);\\n            uint256 value = values.unsafeMemoryAccess(i);\\n\\n            if (from != address(0)) {\\n                uint256 fromBalance = _balances[id][from];\\n                if (fromBalance < value) {\\n                    revert ERC1155InsufficientBalance(from, fromBalance, value, id);\\n                }\\n                unchecked {\\n                    // Overflow not possible: value <= fromBalance\\n                    _balances[id][from] = fromBalance - value;\\n                }\\n            }\\n\\n            if (to != address(0)) {\\n                _balances[id][to] += value;\\n            }\\n        }\\n\\n        if (ids.length == 1) {\\n            uint256 id = ids.unsafeMemoryAccess(0);\\n            uint256 value = values.unsafeMemoryAccess(0);\\n            emit TransferSingle(operator, from, to, id, value);\\n        } else {\\n            emit TransferBatch(operator, from, to, ids, values);\\n        }\\n    }\\n\\n    /**\\n     * @dev Version of {_update} that performs the token acceptance check by calling\\n     * {IERC1155Receiver-onERC1155Received} or {IERC1155Receiver-onERC1155BatchReceived} on the receiver address if it\\n     * contains code (eg. is a smart contract at the moment of execution).\\n     *\\n     * IMPORTANT: Overriding this function is discouraged because it poses a reentrancy risk from the receiver. So any\\n     * update to the contract state after this function would break the check-effect-interaction pattern. Consider\\n     * overriding {_update} instead.\\n     */\\n    function _updateWithAcceptanceCheck(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory values,\\n        bytes memory data\\n    ) internal virtual {\\n        _update(from, to, ids, values);\\n        if (to != address(0)) {\\n            address operator = _msgSender();\\n            if (ids.length == 1) {\\n                uint256 id = ids.unsafeMemoryAccess(0);\\n                uint256 value = values.unsafeMemoryAccess(0);\\n                _doSafeTransferAcceptanceCheck(operator, from, to, id, value, data);\\n            } else {\\n                _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, values, data);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Transfers a `value` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) internal {\\n        if (to == address(0)) {\\n            revert ERC1155InvalidReceiver(address(0));\\n        }\\n        if (from == address(0)) {\\n            revert ERC1155InvalidSender(address(0));\\n        }\\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\\n        _updateWithAcceptanceCheck(from, to, ids, values, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     * - `ids` and `values` must have the same length.\\n     */\\n    function _safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory values,\\n        bytes memory data\\n    ) internal {\\n        if (to == address(0)) {\\n            revert ERC1155InvalidReceiver(address(0));\\n        }\\n        if (from == address(0)) {\\n            revert ERC1155InvalidSender(address(0));\\n        }\\n        _updateWithAcceptanceCheck(from, to, ids, values, data);\\n    }\\n\\n    /**\\n     * @dev Sets a new URI for all token types, by relying on the token type ID\\n     * substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * By this mechanism, any occurrence of the `\\\\{id\\\\}` substring in either the\\n     * URI or any of the values in the JSON file at said URI will be replaced by\\n     * clients with the token type ID.\\n     *\\n     * For example, the `https://token-cdn-domain/\\\\{id\\\\}.json` URI would be\\n     * interpreted by clients as\\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\\n     * for token type ID 0x4cce0.\\n     *\\n     * See {uri}.\\n     *\\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\\n     * this function emits no events.\\n     */\\n    function _setURI(string memory newuri) internal virtual {\\n        _uri = newuri;\\n    }\\n\\n    /**\\n     * @dev Creates a `value` amount of tokens of type `id`, and assigns them to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _mint(address to, uint256 id, uint256 value, bytes memory data) internal {\\n        if (to == address(0)) {\\n            revert ERC1155InvalidReceiver(address(0));\\n        }\\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\\n        _updateWithAcceptanceCheck(address(0), to, ids, values, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `values` must have the same length.\\n     * - `to` cannot be the zero address.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory values, bytes memory data) internal {\\n        if (to == address(0)) {\\n            revert ERC1155InvalidReceiver(address(0));\\n        }\\n        _updateWithAcceptanceCheck(address(0), to, ids, values, data);\\n    }\\n\\n    /**\\n     * @dev Destroys a `value` amount of tokens of type `id` from `from`\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `from` must have at least `value` amount of tokens of type `id`.\\n     */\\n    function _burn(address from, uint256 id, uint256 value) internal {\\n        if (from == address(0)) {\\n            revert ERC1155InvalidSender(address(0));\\n        }\\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\\n        _updateWithAcceptanceCheck(from, address(0), ids, values, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `from` must have at least `value` amount of tokens of type `id`.\\n     * - `ids` and `values` must have the same length.\\n     */\\n    function _burnBatch(address from, uint256[] memory ids, uint256[] memory values) internal {\\n        if (from == address(0)) {\\n            revert ERC1155InvalidSender(address(0));\\n        }\\n        _updateWithAcceptanceCheck(from, address(0), ids, values, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the zero address.\\n     */\\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\\n        if (operator == address(0)) {\\n            revert ERC1155InvalidOperator(address(0));\\n        }\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Performs an acceptance check by calling {IERC1155-onERC1155Received} on the `to` address\\n     * if it contains code at the moment of execution.\\n     */\\n    function _doSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 value,\\n        bytes memory data\\n    ) private {\\n        if (to.code.length > 0) {\\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, value, data) returns (bytes4 response) {\\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\\n                    // Tokens rejected\\n                    revert ERC1155InvalidReceiver(to);\\n                }\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    // non-ERC1155Receiver implementer\\n                    revert ERC1155InvalidReceiver(to);\\n                } else {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a batch acceptance check by calling {IERC1155-onERC1155BatchReceived} on the `to` address\\n     * if it contains code at the moment of execution.\\n     */\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory values,\\n        bytes memory data\\n    ) private {\\n        if (to.code.length > 0) {\\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, values, data) returns (\\n                bytes4 response\\n            ) {\\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\\n                    // Tokens rejected\\n                    revert ERC1155InvalidReceiver(to);\\n                }\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    // non-ERC1155Receiver implementer\\n                    revert ERC1155InvalidReceiver(to);\\n                } else {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Creates an array in memory with only one value for each of the elements provided.\\n     */\\n    function _asSingletonArrays(\\n        uint256 element1,\\n        uint256 element2\\n    ) private pure returns (uint256[] memory array1, uint256[] memory array2) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Load the free memory pointer\\n            array1 := mload(0x40)\\n            // Set array length to 1\\n            mstore(array1, 1)\\n            // Store the single element at the next word after the length (where content starts)\\n            mstore(add(array1, 0x20), element1)\\n\\n            // Repeat for next array locating it right after the first array\\n            array2 := add(array1, 0x40)\\n            mstore(array2, 1)\\n            mstore(add(array2, 0x20), element2)\\n\\n            // Update the free memory pointer by pointing after the second array\\n            mstore(0x40, add(array2, 0x40))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd9b0b8ee1ac6dfee14eb1ad4383a4739dbaa0f2036594bb3a16f0408085dadde\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\\n     *\\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\\n     * to an untrusted contract, when invoking {onERC1155Received} on the receiver.\\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\\n     * reentrancy guards when interacting with untrusted contracts.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\\n     * to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver.\\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\\n     * reentrancy guards when interacting with untrusted contracts.\\n     *\\n     * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `values` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0x6caffc9cfdc623eca9f87a686071708af5d5c17454d65022843fdddbc53c0cce\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface that must be implemented by smart contracts in order to receive\\n * ERC-1155 token transfers.\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xb69597a63b202e28401128bed6a6d259e8730191274471af7303eafb247881a3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Burnable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/extensions/ERC1155Burnable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {ERC1155} from \\\"../ERC1155.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC1155} that allows token holders to destroy both their\\n * own tokens and those that they have been approved to use.\\n */\\nabstract contract ERC1155Burnable is ERC1155 {\\n    function burn(address account, uint256 id, uint256 value) public virtual {\\n        if (account != _msgSender() && !isApprovedForAll(account, _msgSender())) {\\n            revert ERC1155MissingApprovalForAll(_msgSender(), account);\\n        }\\n\\n        _burn(account, id, value);\\n    }\\n\\n    function burnBatch(address account, uint256[] memory ids, uint256[] memory values) public virtual {\\n        if (account != _msgSender() && !isApprovedForAll(account, _msgSender())) {\\n            revert ERC1155MissingApprovalForAll(_msgSender(), account);\\n        }\\n\\n        _burnBatch(account, ids, values);\\n    }\\n}\\n\",\"keccak256\":\"0xdfab949ba677f4b122d0c14225e6db7ca8a65524e2f00049e57b04f68eceeb87\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/extensions/IERC1155MetadataURI.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC1155} from \\\"../IERC1155.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n */\\ninterface IERC1155MetadataURI is IERC1155 {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0xe92b5e199b963d108ad6e06feeede151ba23849e0d064956535489ff967ffe68\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"./extensions/IERC20Metadata.sol\\\";\\nimport {Context} from \\\"../../utils/Context.sol\\\";\\nimport {IERC20Errors} from \\\"../../interfaces/draft-IERC6093.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n */\\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\\n    mapping(address account => uint256) private _balances;\\n\\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `value`.\\n     */\\n    function transfer(address to, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `value`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `value`.\\n     */\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, value);\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _transfer(address from, address to, uint256 value) internal {\\n        if (from == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        if (to == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\\n     * this function.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _update(address from, address to, uint256 value) internal virtual {\\n        if (from == address(0)) {\\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\\n            _totalSupply += value;\\n        } else {\\n            uint256 fromBalance = _balances[from];\\n            if (fromBalance < value) {\\n                revert ERC20InsufficientBalance(from, fromBalance, value);\\n            }\\n            unchecked {\\n                // Overflow not possible: value <= fromBalance <= totalSupply.\\n                _balances[from] = fromBalance - value;\\n            }\\n        }\\n\\n        if (to == address(0)) {\\n            unchecked {\\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\\n                _totalSupply -= value;\\n            }\\n        } else {\\n            unchecked {\\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\\n                _balances[to] += value;\\n            }\\n        }\\n\\n        emit Transfer(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\\n     * Relies on the `_update` mechanism\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _mint(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(address(0), account, value);\\n    }\\n\\n    /**\\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\\n     * Relies on the `_update` mechanism.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead\\n     */\\n    function _burn(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        _update(account, address(0), value);\\n    }\\n\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     *\\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\\n     */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        _approve(owner, spender, value, true);\\n    }\\n\\n    /**\\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\\n     *\\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\\n     * `Approval` event during `transferFrom` operations.\\n     *\\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\\n     * true using the following override:\\n     * ```\\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\\n     *     super._approve(owner, spender, value, true);\\n     * }\\n     * ```\\n     *\\n     * Requirements are the same as {_approve}.\\n     */\\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\\n        if (owner == address(0)) {\\n            revert ERC20InvalidApprover(address(0));\\n        }\\n        if (spender == address(0)) {\\n            revert ERC20InvalidSpender(address(0));\\n        }\\n        _allowances[owner][spender] = value;\\n        if (emitEvent) {\\n            emit Approval(owner, spender, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\\n     *\\n     * Does not update the allowance value in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Does not emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            if (currentAllowance < value) {\\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\\n            }\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - value, false);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc3e1fa9d1987f8d349dfb4d6fe93bf2ca014b52ba335cfac30bfe71e357e6f80\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\",\"keccak256\":\"0xc6a8ff0ea489379b61faa647490411b80102578440ab9d84e9a957cc12164e70\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Burnable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {ERC20} from \\\"../ERC20.sol\\\";\\nimport {Context} from \\\"../../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\nabstract contract ERC20Burnable is Context, ERC20 {\\n    /**\\n     * @dev Destroys a `value` amount of tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 value) public virtual {\\n        _burn(_msgSender(), value);\\n    }\\n\\n    /**\\n     * @dev Destroys a `value` amount of tokens from `account`, deducting from\\n     * the caller's allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for ``accounts``'s tokens of at least\\n     * `value`.\\n     */\\n    function burnFrom(address account, uint256 value) public virtual {\\n        _spendAllowance(account, _msgSender(), value);\\n        _burn(account, value);\\n    }\\n}\\n\",\"keccak256\":\"0x2659248df25e34000ed214b3dc8da2160bc39874c992b477d9e2b1b3283dc073\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0xaa761817f6cd7892fcf158b3c776b34551cde36f48ff9703d53898bc45a94ea2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/ERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/ERC721.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC721} from \\\"./IERC721.sol\\\";\\nimport {IERC721Receiver} from \\\"./IERC721Receiver.sol\\\";\\nimport {IERC721Metadata} from \\\"./extensions/IERC721Metadata.sol\\\";\\nimport {Context} from \\\"../../utils/Context.sol\\\";\\nimport {Strings} from \\\"../../utils/Strings.sol\\\";\\nimport {IERC165, ERC165} from \\\"../../utils/introspection/ERC165.sol\\\";\\nimport {IERC721Errors} from \\\"../../interfaces/draft-IERC6093.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\nabstract contract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Errors {\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    mapping(uint256 tokenId => address) private _owners;\\n\\n    mapping(address owner => uint256) private _balances;\\n\\n    mapping(uint256 tokenId => address) private _tokenApprovals;\\n\\n    mapping(address owner => mapping(address operator => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        if (owner == address(0)) {\\n            revert ERC721InvalidOwner(address(0));\\n        }\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\\n        return _requireOwned(tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\\n        _requireOwned(tokenId);\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual {\\n        _approve(to, tokenId, _msgSender());\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\\n        _requireOwned(tokenId);\\n\\n        return _getApproved(tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\\n        if (to == address(0)) {\\n            revert ERC721InvalidReceiver(address(0));\\n        }\\n        // Setting an \\\"auth\\\" arguments enables the `_isAuthorized` check which verifies that the token exists\\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\\n        address previousOwner = _update(to, tokenId, _msgSender());\\n        if (previousOwner != from) {\\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\\n        }\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\\n        transferFrom(from, to, tokenId);\\n        _checkOnERC721Received(from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\\n     *\\n     * IMPORTANT: Any overrides to this function that add ownership of tokens not tracked by the\\n     * core ERC721 logic MUST be matched with the use of {_increaseBalance} to keep balances\\n     * consistent with ownership. The invariant to preserve is that for any address `a` the value returned by\\n     * `balanceOf(a)` must be equal to the number of tokens such that `_ownerOf(tokenId)` is `a`.\\n     */\\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\\n        return _owners[tokenId];\\n    }\\n\\n    /**\\n     * @dev Returns the approved address for `tokenId`. Returns 0 if `tokenId` is not minted.\\n     */\\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `owner`'s tokens, or `tokenId` in\\n     * particular (ignoring whether it is owned by `owner`).\\n     *\\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\\n     * assumption.\\n     */\\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        return\\n            spender != address(0) &&\\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\\n    }\\n\\n    /**\\n     * @dev Checks if `spender` can operate on `tokenId`, assuming the provided `owner` is the actual owner.\\n     * Reverts if `spender` does not have approval from the provided `owner` for the given token or for all its assets\\n     * the `spender` for the specific `tokenId`.\\n     *\\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\\n     * assumption.\\n     */\\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\\n        if (!_isAuthorized(owner, spender, tokenId)) {\\n            if (owner == address(0)) {\\n                revert ERC721NonexistentToken(tokenId);\\n            } else {\\n                revert ERC721InsufficientApproval(spender, tokenId);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Unsafe write access to the balances, used by extensions that \\\"mint\\\" tokens using an {ownerOf} override.\\n     *\\n     * NOTE: the value is limited to type(uint128).max. This protect against _balance overflow. It is unrealistic that\\n     * a uint256 would ever overflow from increments when these increments are bounded to uint128 values.\\n     *\\n     * WARNING: Increasing an account's balance using this function tends to be paired with an override of the\\n     * {_ownerOf} function to resolve the ownership of the corresponding tokens so that balances and ownership\\n     * remain consistent with one another.\\n     */\\n    function _increaseBalance(address account, uint128 value) internal virtual {\\n        unchecked {\\n            _balances[account] += value;\\n        }\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from its current owner to `to`, or alternatively mints (or burns) if the current owner\\n     * (or `to`) is the zero address. Returns the owner of the `tokenId` before the update.\\n     *\\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that\\n     * `auth` is either the owner of the token, or approved to operate on the token (by the owner).\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * NOTE: If overriding this function in a way that tracks balances, see also {_increaseBalance}.\\n     */\\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\\n        address from = _ownerOf(tokenId);\\n\\n        // Perform (optional) operator check\\n        if (auth != address(0)) {\\n            _checkAuthorized(from, auth, tokenId);\\n        }\\n\\n        // Execute the update\\n        if (from != address(0)) {\\n            // Clear approval. No need to re-authorize or emit the Approval event\\n            _approve(address(0), tokenId, address(0), false);\\n\\n            unchecked {\\n                _balances[from] -= 1;\\n            }\\n        }\\n\\n        if (to != address(0)) {\\n            unchecked {\\n                _balances[to] += 1;\\n            }\\n        }\\n\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n\\n        return from;\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal {\\n        if (to == address(0)) {\\n            revert ERC721InvalidReceiver(address(0));\\n        }\\n        address previousOwner = _update(to, tokenId, address(0));\\n        if (previousOwner != address(0)) {\\n            revert ERC721InvalidSender(address(0));\\n        }\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId`, transfers it to `to` and checks for `to` acceptance.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\\n        _mint(to, tokenId);\\n        _checkOnERC721Received(address(0), to, tokenId, data);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal {\\n        address previousOwner = _update(address(0), tokenId, address(0));\\n        if (previousOwner == address(0)) {\\n            revert ERC721NonexistentToken(tokenId);\\n        }\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(address from, address to, uint256 tokenId) internal {\\n        if (to == address(0)) {\\n            revert ERC721InvalidReceiver(address(0));\\n        }\\n        address previousOwner = _update(to, tokenId, address(0));\\n        if (previousOwner == address(0)) {\\n            revert ERC721NonexistentToken(tokenId);\\n        } else if (previousOwner != from) {\\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\\n        }\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking that contract recipients\\n     * are aware of the ERC721 standard to prevent tokens from being forever locked.\\n     *\\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is like {safeTransferFrom} in the sense that it invokes\\n     * {IERC721Receiver-onERC721Received} on the receiver, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - `to` cannot be the zero address.\\n     * - `from` cannot be the zero address.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\\n        _safeTransfer(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeTransfer-address-address-uint256-}[`_safeTransfer`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\\n        _transfer(from, to, tokenId);\\n        _checkOnERC721Received(from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that `auth` is\\n     * either the owner of the token, or approved to operate on all tokens held by this owner.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\\n     */\\n    function _approve(address to, uint256 tokenId, address auth) internal {\\n        _approve(to, tokenId, auth, true);\\n    }\\n\\n    /**\\n     * @dev Variant of `_approve` with an optional flag to enable or disable the {Approval} event. The event is not\\n     * emitted in the context of transfers.\\n     */\\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\\n        // Avoid reading the owner unless necessary\\n        if (emitEvent || auth != address(0)) {\\n            address owner = _requireOwned(tokenId);\\n\\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\\n                revert ERC721InvalidApprover(auth);\\n            }\\n\\n            if (emitEvent) {\\n                emit Approval(owner, to, tokenId);\\n            }\\n        }\\n\\n        _tokenApprovals[tokenId] = to;\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Requirements:\\n     * - operator can't be the address zero.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\\n        if (operator == address(0)) {\\n            revert ERC721InvalidOperator(operator);\\n        }\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Reverts if the `tokenId` doesn't have a current owner (it hasn't been minted, or it has been burned).\\n     * Returns the owner.\\n     *\\n     * Overrides to ownership logic should be done to {_ownerOf}.\\n     */\\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\\n        address owner = _ownerOf(tokenId);\\n        if (owner == address(0)) {\\n            revert ERC721NonexistentToken(tokenId);\\n        }\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target address. This will revert if the\\n     * recipient doesn't accept the token transfer. The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param data bytes optional data to send along with the call\\n     */\\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\\n        if (to.code.length > 0) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\\n                if (retval != IERC721Receiver.onERC721Received.selector) {\\n                    revert ERC721InvalidReceiver(to);\\n                }\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert ERC721InvalidReceiver(to);\\n                } else {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x13dd061770956c8489b80cfc89d9cdfc8ea2783d953691ea037a380731d52784\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\\n     *   {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the address zero.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x5ef46daa3b58ef2702279d514780316efaa952915ee1aa3396f041ee2982b0b4\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\\n     * reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0x7f7a26306c79a65fb8b3b6c757cd74660c532cd8a02e165488e30027dd34ca49\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/ERC721Burnable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {ERC721} from \\\"../ERC721.sol\\\";\\nimport {Context} from \\\"../../../utils/Context.sol\\\";\\n\\n/**\\n * @title ERC721 Burnable Token\\n * @dev ERC721 Token that can be burned (destroyed).\\n */\\nabstract contract ERC721Burnable is Context, ERC721 {\\n    /**\\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own `tokenId` or be an approved operator.\\n     */\\n    function burn(uint256 tokenId) public virtual {\\n        // Setting an \\\"auth\\\" arguments enables the `_isAuthorized` check which verifies that the token exists\\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\\n        _update(address(0), tokenId, _msgSender());\\n    }\\n}\\n\",\"keccak256\":\"0xc48434419baa510862ba4b4802bc0500ccddadd02ae2f195548af748c3206b20\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC721} from \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x37d1aaaa5a2908a09e9dcf56a26ddf762ecf295afb5964695937344fc6802ce1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Arrays.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Arrays.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {StorageSlot} from \\\"./StorageSlot.sol\\\";\\nimport {Math} from \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev Collection of functions related to array types.\\n */\\nlibrary Arrays {\\n    using StorageSlot for bytes32;\\n\\n    /**\\n     * @dev Searches a sorted `array` and returns the first index that contains\\n     * a value greater or equal to `element`. If no such index exists (i.e. all\\n     * values in the array are strictly less than `element`), the array length is\\n     * returned. Time complexity O(log n).\\n     *\\n     * `array` is expected to be sorted in ascending order, and to contain no\\n     * repeated elements.\\n     */\\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\\n        uint256 low = 0;\\n        uint256 high = array.length;\\n\\n        if (high == 0) {\\n            return 0;\\n        }\\n\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n\\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\n            // because Math.average rounds towards zero (it does integer division with truncation).\\n            if (unsafeAccess(array, mid).value > element) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\\n        if (low > 0 && unsafeAccess(array, low - 1).value == element) {\\n            return low - 1;\\n        } else {\\n            return low;\\n        }\\n    }\\n\\n    /**\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\n     *\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\n     */\\n    function unsafeAccess(address[] storage arr, uint256 pos) internal pure returns (StorageSlot.AddressSlot storage) {\\n        bytes32 slot;\\n        // We use assembly to calculate the storage slot of the element at index `pos` of the dynamic array `arr`\\n        // following https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays.\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0, arr.slot)\\n            slot := add(keccak256(0, 0x20), pos)\\n        }\\n        return slot.getAddressSlot();\\n    }\\n\\n    /**\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\n     *\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\n     */\\n    function unsafeAccess(bytes32[] storage arr, uint256 pos) internal pure returns (StorageSlot.Bytes32Slot storage) {\\n        bytes32 slot;\\n        // We use assembly to calculate the storage slot of the element at index `pos` of the dynamic array `arr`\\n        // following https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays.\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0, arr.slot)\\n            slot := add(keccak256(0, 0x20), pos)\\n        }\\n        return slot.getBytes32Slot();\\n    }\\n\\n    /**\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\n     *\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\n     */\\n    function unsafeAccess(uint256[] storage arr, uint256 pos) internal pure returns (StorageSlot.Uint256Slot storage) {\\n        bytes32 slot;\\n        // We use assembly to calculate the storage slot of the element at index `pos` of the dynamic array `arr`\\n        // following https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays.\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0, arr.slot)\\n            slot := add(keccak256(0, 0x20), pos)\\n        }\\n        return slot.getUint256Slot();\\n    }\\n\\n    /**\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\n     *\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\n     */\\n    function unsafeMemoryAccess(uint256[] memory arr, uint256 pos) internal pure returns (uint256 res) {\\n        assembly {\\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\\n        }\\n    }\\n\\n    /**\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\n     *\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\n     */\\n    function unsafeMemoryAccess(address[] memory arr, uint256 pos) internal pure returns (address res) {\\n        assembly {\\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8806d620b6571932b662cfd48fbd518d4f70df1f88a23b5724cacde64a77bda1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0x493033a8d1b176a037b2cc6a04dad01a5c157722049bbecf632ca876224dd4b2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/StorageSlot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(newImplementation.code.length > 0);\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x32ba59b4b7299237c8ba56319110989d7978a039faf754793064e967e5894418\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Math} from \\\"./math/Math.sol\\\";\\nimport {SignedMath} from \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant HEX_DIGITS = \\\"0123456789abcdef\\\";\\n    uint8 private constant ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev The `value` string doesn't fit in the specified `length`.\\n     */\\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toStringSigned(int256 value) internal pure returns (string memory) {\\n        return string.concat(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value)));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        uint256 localValue = value;\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\\n            localValue >>= 4;\\n        }\\n        if (localValue != 0) {\\n            revert StringsInsufficientHexLength(value, length);\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\\n     * representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\",\"keccak256\":\"0x55f102ea785d8399c0e58d1108e2d289506dde18abc6db1b7f68c1f9f9bc5792\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS\\n    }\\n\\n    /**\\n     * @dev The signature derives the `address(0)`.\\n     */\\n    error ECDSAInvalidSignature();\\n\\n    /**\\n     * @dev The signature has an invalid length.\\n     */\\n    error ECDSAInvalidSignatureLength(uint256 length);\\n\\n    /**\\n     * @dev The signature has an S value that is in the upper half order.\\n     */\\n    error ECDSAInvalidSignatureS(bytes32 s);\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\\n     * and a bytes32 providing additional information about the error.\\n     *\\n     * If no error is returned, then the address can be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\\n        _throwError(error, errorArg);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\\n        unchecked {\\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\\n            return tryRecover(hash, v, r, s);\\n        }\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\\n        _throwError(error, errorArg);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError, bytes32) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS, s);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\\n        }\\n\\n        return (signer, RecoverError.NoError, bytes32(0));\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\\n        _throwError(error, errorArg);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\\n     */\\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert ECDSAInvalidSignature();\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert ECDSAInvalidSignatureS(errorArg);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xeed0a08b0b091f528356cbc7245891a4c748682d4f6a18055e8e6ca77d12a6cf\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Strings} from \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\\n *\\n * The library provides methods for generating a hash of a message that conforms to the\\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\\n * specifications.\\n */\\nlibrary MessageHashUtils {\\n    /**\\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\\n     * `0x45` (`personal_sign` messages).\\n     *\\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\\n     * `\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\"` and hashing the result. It corresponds with the\\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\\n     *\\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\\n     * keccak256, although any bytes32 value can be safely used because the final digest will\\n     * be re-hashed.\\n     *\\n     * See {ECDSA-recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\") // 32 is the bytes-length of messageHash\\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\\n     * `0x45` (`personal_sign` messages).\\n     *\\n     * The digest is calculated by prefixing an arbitrary `message` with\\n     * `\\\"\\\\x19Ethereum Signed Message:\\\\n\\\" + len(message)` and hashing the result. It corresponds with the\\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\\n     *\\n     * See {ECDSA-recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\\n        return\\n            keccak256(bytes.concat(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", bytes(Strings.toString(message.length)), message));\\n    }\\n\\n    /**\\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\\n     * `0x00` (data with intended validator).\\n     *\\n     * The digest is calculated by prefixing an arbitrary `data` with `\\\"\\\\x19\\\\x00\\\"` and the intended\\n     * `validator` address. Then hashing the result.\\n     *\\n     * See {ECDSA-recover}.\\n     */\\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(hex\\\"19_00\\\", validator, data));\\n    }\\n\\n    /**\\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\\n     *\\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\\n     * `\\\\x19\\\\x01` and hashing the result. It corresponds to the hash signed by the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\\n     *\\n     * See {ECDSA-recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, hex\\\"19_01\\\")\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            digest := keccak256(ptr, 0x42)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xba333517a3add42cd35fe877656fc3dfcc9de53baa4f3aabbd6d12a92e4ea435\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/SignatureChecker.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {ECDSA} from \\\"./ECDSA.sol\\\";\\nimport {IERC1271} from \\\"../../interfaces/IERC1271.sol\\\";\\n\\n/**\\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\\n * Argent and Safe Wallet (previously Gnosis Safe).\\n */\\nlibrary SignatureChecker {\\n    /**\\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\\n     *\\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\\n     */\\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\\n        (address recovered, ECDSA.RecoverError error, ) = ECDSA.tryRecover(hash, signature);\\n        return\\n            (error == ECDSA.RecoverError.NoError && recovered == signer) ||\\n            isValidERC1271SignatureNow(signer, hash, signature);\\n    }\\n\\n    /**\\n     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated\\n     * against the signer smart contract using ERC1271.\\n     *\\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\\n     */\\n    function isValidERC1271SignatureNow(\\n        address signer,\\n        bytes32 hash,\\n        bytes memory signature\\n    ) internal view returns (bool) {\\n        (bool success, bytes memory result) = signer.staticcall(\\n            abi.encodeCall(IERC1271.isValidSignature, (hash, signature))\\n        );\\n        return (success &&\\n            result.length >= 32 &&\\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\\n    }\\n}\\n\",\"keccak256\":\"0x6b11eb41a228cca35d4b662b4df69fcd75192851365102690f57b2ac01e83fe6\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0x9e8778b14317ba9e256c30a76fd6c32b960af621987f56069e1e819c77c6a133\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165Checker.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165Checker {\\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n    bytes4 private constant INTERFACE_ID_INVALID = 0xffffffff;\\n\\n    /**\\n     * @dev Returns true if `account` supports the {IERC165} interface.\\n     */\\n    function supportsERC165(address account) internal view returns (bool) {\\n        // Any contract that implements ERC165 must explicitly indicate support of\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n        return\\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\\n            !supportsERC165InterfaceUnchecked(account, INTERFACE_ID_INVALID);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports the interface defined by\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // query support of both ERC165 as per the spec and support of _interfaceId\\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns a boolean array where each value corresponds to the\\n     * interfaces passed in and whether they're supported or not. This allows\\n     * you to batch check interfaces for a contract where your expectation\\n     * is that some interfaces may not be supported.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function getSupportedInterfaces(\\n        address account,\\n        bytes4[] memory interfaceIds\\n    ) internal view returns (bool[] memory) {\\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\\n\\n        // query support of ERC165 itself\\n        if (supportsERC165(account)) {\\n            // query support of each interface in interfaceIds\\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\\n            }\\n        }\\n\\n        return interfaceIdsSupported;\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports all the interfaces defined in\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\n     * {IERC165} support.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\\n        // query support of ERC165 itself\\n        if (!supportsERC165(account)) {\\n            return false;\\n        }\\n\\n        // query support of each interface in interfaceIds\\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\\n                return false;\\n            }\\n        }\\n\\n        // all interfaces supported\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Query if a contract implements an interface, does not check ERC165 support\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return true if the contract at account indicates support of the interface with\\n     * identifier interfaceId, false otherwise\\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n     * the behavior of this method is undefined. This precondition can be checked\\n     * with {supportsERC165}.\\n     *\\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\\n     * should be exercised when using this function.\\n     *\\n     * Interface identification is specified in ERC-165.\\n     */\\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // prepare call\\n        bytes memory encodedParams = abi.encodeCall(IERC165.supportsInterface, (interfaceId));\\n\\n        // perform static call\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly {\\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\\n            returnSize := returndatasize()\\n            returnValue := mload(0x00)\\n        }\\n\\n        return success && returnSize >= 0x20 && returnValue > 0;\\n    }\\n}\\n\",\"keccak256\":\"0xac3d50e321a48a40b4496970ce725900f13aeb2255b7c1203f5adbe98c4a911a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x4296879f55019b23e135000eb36896057e7101fb7fb859c5ef690cf14643757b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Muldiv operation overflow.\\n     */\\n    error MathOverflowedMulDiv();\\n\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            return a / b;\\n        }\\n\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            if (denominator <= prod1) {\\n                revert MathOverflowedMulDiv();\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\",\"keccak256\":\"0x005ec64c6313f0555d59e278f9a7a5ab2db5bdc72a027f255a37c327af1ec02d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5f7e4076e175393767754387c962926577f1660dd9b810187b9002407656be72\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position is the index of the value in the `values` array plus 1.\\n        // Position 0 is used to mean a value is not in the set.\\n        mapping(bytes32 value => uint256) _positions;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._positions[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We cache the value's position to prevent multiple reads from the same storage slot\\n        uint256 position = set._positions[value];\\n\\n        if (position != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 valueIndex = position - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (valueIndex != lastIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the lastValue to the index where the value to delete is\\n                set._values[valueIndex] = lastValue;\\n                // Update the tracked position of the lastValue (that was just moved)\\n                set._positions[lastValue] = position;\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the tracked position for the deleted slot\\n            delete set._positions[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._positions[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0x86c1470cbfd878491e5de030072b647352d36bd27122cffb928970b1945282aa\",\"license\":\"MIT\"},\"@peeramid-labs/eds/src/ICodeIndex.sol\":{\"content\":\"// SPDX-License-Identifier: CC0-1.0\\npragma solidity 0.8.20;\\n\\ninterface ICodeIndex {\\n    event Indexed(address indexed container, bytes32 indexed codeHash);\\n    error alreadyExists(bytes32 id, address source);\\n\\n    function register(address container) external;\\n\\n    function get(bytes32 id) external view returns (address);\\n}\",\"keccak256\":\"0x46ba8ab4127e5d6f2171d84c15cea75e530d48fb8997766002a45fe1014766dd\",\"license\":\"CC0-1.0\"},\"@peeramid-labs/eds/src/abstracts/CloneDistribution.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\nimport \\\"../interfaces/IDistribution.sol\\\";\\nimport \\\"./CodeIndexer.sol\\\";\\n\\nabstract contract CloneDistribution is IDistribution, CodeIndexer {\\n    error CodeNotFoundInIndex(bytes32 codeId);\\n\\n    function sources() internal view virtual returns (address[] memory, bytes32 name, uint256 version);\\n\\n    // @inheritdoc IDistribution\\n    function _instantiate()\\n        internal\\n        virtual\\n        returns (address[] memory instances, bytes32 distributionName, uint256 distributionVersion)\\n    {\\n        (address[] memory _sources, bytes32 _distributionName, uint256 _distributionVersion) = sources();\\n        uint256 srcsLength = _sources.length;\\n        instances = new address[](srcsLength);\\n        for (uint256 i; i < srcsLength; ++i) {\\n            address clone = Clones.clone(_sources[i]);\\n            instances[i] = clone;\\n        }\\n        emit Distributed(msg.sender, instances);\\n        return (instances, _distributionName, _distributionVersion);\\n    }\\n    // @inheritdoc IDistribution\\n    function get() external view virtual returns (address[] memory src, bytes32 name, uint256 version) {\\n        return sources();\\n    }\\n    // @inheritdoc IDistribution\\n    function contractURI() external view virtual returns (string memory);\\n}\\n\",\"keccak256\":\"0x759986bffb39959497e361e41516251306631b078b98e38268cd216217048bdd\",\"license\":\"MIT\"},\"@peeramid-labs/eds/src/abstracts/CodeIndexer.sol\":{\"content\":\"// SPDX-License-Identifier: CC0-1.0\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"../ICodeIndex.sol\\\";\\n\\nabstract contract CodeIndexer {\\n    //Create2 contract\\n    ICodeIndex private constant INDEX_CONTRACT = ICodeIndex(0xc0D31d398c5ee86C5f8a23FA253ee8a586dA03Ce);\\n    constructor() {}\\n    // @inheritdoc ICodeIndex\\n    function getContractsIndex() internal pure returns (ICodeIndex) {\\n        return INDEX_CONTRACT;\\n    }\\n    // @inheritdoc ICodeIndex\\n    function index(address source) internal {\\n        INDEX_CONTRACT.register(source);\\n    }\\n}\\n\",\"keccak256\":\"0xb5c35149f116be89dddf7a5c7ffab92fd29482b1e3c28e4ef26d8df689a8d95e\",\"license\":\"CC0-1.0\"},\"@peeramid-labs/eds/src/interfaces/IContractURI.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\ninterface IContractURI {\\n    function contractURI() external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x7adffebc6e64c642e132bbff8ff695138517023f710b23b8767708de4f73db0b\",\"license\":\"MIT\"},\"@peeramid-labs/eds/src/interfaces/IDistribution.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\nimport {IContractURI} from \\\"./IContractURI.sol\\\";\\n/**\\n * @title IDistribution\\n * @notice Interface for distribution-related functionalities. It can get sources and produce a new instances out from them. It also provides metadata about the distribution.\\n * @dev It is highly recommended to keep implementation stateless, and use `immutable` variables for any state. This allows your code to be referred in distributor and respositories via ERC7744. It's also easier to reason about, and more gas efficient.\\n * @author Peeramid Labs, 2024\\n */\\ninterface IDistribution is IContractURI {\\n    /**\\n     * @notice Emitted when a distribution occurs.\\n     * @param distributor The address of the entity that performed the distribution.\\n     * @param instances An array of addresses that were produced.\\n     */\\n    event Distributed(address indexed distributor, address[] instances);\\n\\n    /**\\n     * @notice Instantiates a new instance with the given parameters.\\n     * @param data The data to be used for instantiation.\\n     * @return instances An array of addresses that were produced.\\n     * @return distributionName The name of the distribution.\\n     * @return distributionVersion The version of the distribution.\\n     * @dev WARNING: It MUST emit Distributed event.\\n     */\\n    function instantiate(\\n        bytes memory data\\n    ) external returns (address[] memory instances, bytes32 distributionName, uint256 distributionVersion);\\n\\n    /**\\n     * @notice Retrieves the current distribution sources.\\n     * @return sources An array of addresses that are used for instantiation.\\n     * @return distributionName The name of the distribution.\\n     * @return distributionVersion The version of the distribution.\\n     */\\n    function get()\\n        external\\n        view\\n        returns (address[] memory sources, bytes32 distributionName, uint256 distributionVersion);\\n}\\n\",\"keccak256\":\"0x8d8bfa27277d68b5defe449c4af09be60cefa0b275d7b25022921502f34e5d63\",\"license\":\"MIT\"},\"@peeramid-labs/eds/src/libraries/LibSemver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nlibrary LibSemver {\\n    error versionMissmatch(string message);\\n    struct Version {\\n        uint64 major;\\n        uint64 minor;\\n        uint128 patch;\\n    }\\n\\n    enum requirements {\\n        ANY, // *\\n        EXACT, // =\\n        MAJOR, // ^\\n        MAJOR_MINOR, // ~\\n        GREATER_EQUAL, // >=\\n        GREATER, // >\\n        LESSER_EQUAL, // <=\\n        LESSER // <\\n    }\\n\\n    struct VersionRequirement {\\n        Version version;\\n        requirements requirement;\\n    }\\n\\n    function toUint256(Version memory _version) internal pure returns (uint256) {\\n        return (uint256(_version.major) << 192) | (uint256(_version.minor) << 128) | uint256(_version.patch);\\n    }\\n\\n    function parse(uint256 _version) internal pure returns (Version memory) {\\n        return Version(uint64(_version >> 192), uint64(_version >> 128), uint128(_version));\\n    }\\n\\n    function toString(Version memory _version) internal pure returns (string memory) {\\n        return\\n            string(\\n                abi.encodePacked(\\n                    Strings.toString(uint256(_version.major)),\\n                    \\\".\\\",\\n                    Strings.toString(uint256(_version.minor)),\\n                    \\\".\\\",\\n                    Strings.toString(uint256(_version.patch))\\n                )\\n            );\\n    }\\n\\n    function require_exact(Version memory _version1, Version memory _version2) internal pure {\\n        if (toUint256(_version1) != toUint256(_version2)) revert versionMissmatch(\\\"Version mismatch\\\");\\n    }\\n\\n    function require_major(Version memory _version1, Version memory _version2) internal pure {\\n        if (_version1.major != _version2.major) revert versionMissmatch(\\\"Major version mismatch\\\");\\n    }\\n\\n    function require_major_minor(Version memory _version1, Version memory _version2) internal pure {\\n        if (_version1.major != _version2.major || _version1.minor != _version2.minor)\\n            revert versionMissmatch(\\\"Major and minor version mismatch\\\");\\n    }\\n\\n    function require_greater_equal(Version memory _version1, Version memory _version2) internal pure {\\n        if (toUint256(_version1) < toUint256(_version2)) revert versionMissmatch(\\\"Version is not greater or equal\\\");\\n    }\\n\\n    function require_greater(Version memory _version1, Version memory _version2) internal pure {\\n        if (toUint256(_version1) <= toUint256(_version2)) revert versionMissmatch(\\\"Version is not greater\\\");\\n    }\\n\\n    function require_lesser_equal(Version memory _version1, Version memory _version2) internal pure {\\n        if (toUint256(_version1) > toUint256(_version2)) revert versionMissmatch(\\\"Version is not lesser or equal\\\");\\n    }\\n\\n    function require_lesser(Version memory _version1, Version memory _version2) internal pure {\\n        if (toUint256(_version1) >= toUint256(_version2)) revert versionMissmatch(\\\"Version is not lesser\\\");\\n    }\\n\\n    function areEqual(Version memory _version1, Version memory _version2) internal pure returns (bool) {\\n        return toUint256(_version1) == toUint256(_version2);\\n    }\\n\\n    function compare(Version memory has, VersionRequirement memory needs) internal pure returns (bool) {\\n        if (needs.requirement == requirements.ANY) return true;\\n        if (needs.requirement == requirements.EXACT) return toUint256(has) == toUint256(needs.version);\\n        if (needs.requirement == requirements.MAJOR) return has.major == needs.version.major;\\n        if (needs.requirement == requirements.MAJOR_MINOR)\\n            return has.major == needs.version.major && has.minor == needs.version.minor;\\n        if (needs.requirement == requirements.GREATER_EQUAL) return toUint256(has) >= toUint256(needs.version);\\n        if (needs.requirement == requirements.GREATER) return toUint256(has) > toUint256(needs.version);\\n        if (needs.requirement == requirements.LESSER_EQUAL) return toUint256(has) <= toUint256(needs.version);\\n        if (needs.requirement == requirements.LESSER) return toUint256(has) < toUint256(needs.version);\\n        return false;\\n    }\\n\\n    function getNextMajor(Version memory _version) internal pure returns (Version memory) {\\n        return Version(_version.major + 1, 0, 0);\\n    }\\n\\n    function getNextMinor(Version memory _version) internal pure returns (Version memory) {\\n        return Version(_version.major, _version.minor + 1, 0);\\n    }\\n\\n    function getNextPatch(Version memory _version) internal pure returns (Version memory) {\\n        return Version(_version.major, _version.minor, _version.patch + 1);\\n    }\\n}\\n\",\"keccak256\":\"0x71544e4e1ad3b6aefb0ccbd8d3abce33ab8cd26cb8d51ee45bb8419ac92bd787\",\"license\":\"MIT\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS =\\n        0x000000000000000000636F6e736F6c652e6c6f67;\\n\\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    consoleAddress,\\n                    add(payload, 32),\\n                    mload(payload),\\n                    0,\\n                    0\\n                )\\n            )\\n        }\\n    }\\n\\n    function _castToPure(\\n      function(bytes memory) internal view fnIn\\n    ) internal pure returns (function(bytes memory) pure fnOut) {\\n        assembly {\\n            fnOut := fnIn\\n        }\\n    }\\n\\n    function _sendLogPayload(bytes memory payload) internal pure {\\n        _castToPure(_sendLogPayloadImplementation)(payload);\\n    }\\n\\n    function log() internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n\\n    function logInt(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function logUint(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n}\\n\",\"keccak256\":\"0xf2560b5386574153057104d19a9e68a32ee912cf23c0c8df1fe9a0607f42d543\",\"license\":\"MIT\"},\"src/abstracts/DiamondReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\n/**\\n * Author: @Peersky https://github.com/peersky\\n * Adapted this diamond reentrancy guard from:\\n\\n * Authors: Moonstream Engineering (engineering@moonstream.to)\\n * GitHub: https://github.com/bugout-dev/dao\\n */\\n\\npragma solidity ^0.8.20;\\nimport \\\"../libraries/LibReentrancyGuard.sol\\\";\\n\\nabstract contract DiamondReentrancyGuard {\\n    modifier nonReentrant() {\\n        LibReentrancyGuard.ReentrancyGuardStruct storage rgs = LibReentrancyGuard.reentrancyGuardStorage();\\n        require(!rgs._entered, \\\"REG: You shall not pass!\\\");\\n        rgs._entered = true;\\n        _;\\n        rgs._entered = false;\\n    }\\n}\\n\",\"keccak256\":\"0xfe1f8e71dc63f898ba9ae59193b975352955e0f8c1a694a78cab07df3389cd91\",\"license\":\"Apache-2.0\"},\"src/abstracts/draft-EIP712Diamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\\\";\\nimport \\\"../libraries/LibEIP712Storage.sol\\\";\\nimport \\\"../modifiers/OnlyOwnerDiamond.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * _Available since v3.4._\\n */\\nabstract contract EIP712 is OnlyOwnerDiamond {\\n    /* solhint-disable var-name-mixedcase */\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\n    // invalidate the cached domain separator if the chain id changes.\\n\\n    /* solhint-enable var-name-mixedcase */\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    constructor() {}\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        LibEIP712WithStorage.LibEIP712WithStorageStorage storage ss = LibEIP712WithStorage.EIP712WithStorage();\\n        if (address(this) == ss._CACHED_THIS && block.chainid == ss._CACHED_CHAIN_ID) {\\n            return ss._CACHED_DOMAIN_SEPARATOR;\\n        } else {\\n            return _buildDomainSeparator(ss._TYPE_HASH, ss._HASHED_NAME, ss._HASHED_VERSION);\\n        }\\n    }\\n\\n    function _buildDomainSeparator(\\n        bytes32 typeHash,\\n        bytes32 nameHash,\\n        bytes32 versionHash\\n    ) private view returns (bytes32) {\\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n}\\n\",\"keccak256\":\"0x127b859f8989a2eaaa446254219f98eb3049f66027b280ace44394c34e895aa6\",\"license\":\"MIT\"},\"src/distributions/ArguableVotingTournament.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"./InitializedDiamondDistribution.sol\\\";\\nimport \\\"../vendor/diamond/facets/DiamondLoupeFacet.sol\\\";\\nimport \\\"../facets/EIP712InspectorFacet.sol\\\";\\nimport \\\"../vendor/diamond/facets/OwnershipFacet.sol\\\";\\nimport \\\"../facets/RankifyInstanceMainFacet.sol\\\";\\nimport \\\"../facets/RankifyInstanceRequirementsFacet.sol\\\";\\nimport \\\"../facets/RankifyInstanceGameMastersFacet.sol\\\";\\nimport \\\"../facets/RankifyInstanceGameOwnersFacet.sol\\\";\\nimport \\\"../initializers/RankifyInstanceInit.sol\\\";\\nimport \\\"../vendor/diamond/interfaces/IDiamondCut.sol\\\";\\nimport \\\"@peeramid-labs/eds/src/libraries/LibSemver.sol\\\";\\n\\n/**\\n * @title ArguableVotingTournament Distribution\\n * @notice This contract implements a diamond distribution for Ethereum Distribution System. It is reponsible to create new instance of ArguableVotingTournament.\\n * @dev It is expected to be used ONLY by the Distributor contract.\\n * @author Peeramid Labs, 2024\\n */\\ncontract ArguableVotingTournament is InitializedDiamondDistribution {\\n    DiamondLoupeFacet private immutable _loupeFacet;\\n    EIP712InspectorFacet private immutable _inspectorFacet;\\n    RankifyInstanceMainFacet private immutable _RankifyMainFacet;\\n    RankifyInstanceRequirementsFacet private immutable _RankifyReqsFacet;\\n    RankifyInstanceGameMastersFacet private immutable _RankifyGMFacet;\\n    RankifyInstanceGameOwnersFacet private immutable _RankifyOwnerFacet;\\n    OwnershipFacet private immutable _OwnershipFacet;\\n    address private immutable _initializer;\\n\\n    bytes32 private immutable distributionName;\\n    uint256 private immutable distributionVersion;\\n\\n    function stringToSelector(string memory signature) private pure returns (bytes4) {\\n        return bytes4(keccak256(bytes(signature)));\\n    }\\n\\n    /**\\n     * @dev Constructor for the ArguableVotingTournament contract.\\n     *\\n     * Note Initializer function will be added as a regular facet to the Diamond Proxy,\\n     * Since it is expected that initialization is done by distributor contract, the initializer will not be run, hence\\n     * it is up for distributor to remove this facet upon succesfull initialization.\\n     */\\n    constructor(\\n        address initializer,\\n        bytes4 initializerSelector,\\n        bytes32 _distributionName,\\n        LibSemver.Version memory version,\\n        address loupeFacet,\\n        address inspectorFacet,\\n        address RankifyMainFacet,\\n        address RankifyReqsFacet,\\n        address RankifyGMFacet,\\n        address RankifyOwnerFacet,\\n        address OwnershipFacetAddr\\n    ) InitializedDiamondDistribution(address(this), bytes32(0), initializerSelector) {\\n        _initializer = initializer;\\n        _loupeFacet = DiamondLoupeFacet(loupeFacet);\\n        _inspectorFacet = EIP712InspectorFacet(inspectorFacet);\\n        _RankifyMainFacet = RankifyInstanceMainFacet(RankifyMainFacet);\\n        _RankifyReqsFacet = RankifyInstanceRequirementsFacet(RankifyReqsFacet);\\n        _RankifyGMFacet = RankifyInstanceGameMastersFacet(RankifyGMFacet);\\n        _RankifyOwnerFacet = RankifyInstanceGameOwnersFacet(RankifyOwnerFacet);\\n        _OwnershipFacet = OwnershipFacet(OwnershipFacetAddr);\\n\\n        distributionName = _distributionName;\\n        distributionVersion = LibSemver.toUint256(version);\\n    }\\n\\n    /**\\n     * @dev see Ethereum Distribution System IDistribute for interface specification.\\n     * @return instances Array[9]: [diamond proxy, 8x diamond facets..]\\n     * @return distributionName: bytes32 encoded name to be used in EIP712 signing flow\\n     * @return distributionVersion: uint256 encoded distribution version. Can be parsed to eip712 signature with EDS LibSemver\\n     */\\n    function instantiate(bytes memory) external override returns (address[] memory instances, bytes32, uint256) {\\n        (address[] memory _instances, , ) = super._instantiate();\\n        address diamond = _instances[0];\\n        IDiamondCut.FacetCut[] memory facetCuts = new IDiamondCut.FacetCut[](8);\\n\\n        bytes4[] memory loupeSelectors = new bytes4[](4);\\n        loupeSelectors[0] = DiamondLoupeFacet.facets.selector;\\n        loupeSelectors[1] = DiamondLoupeFacet.facetFunctionSelectors.selector;\\n        loupeSelectors[2] = DiamondLoupeFacet.facetAddresses.selector;\\n        loupeSelectors[3] = DiamondLoupeFacet.facetAddress.selector;\\n        facetCuts[0] = IDiamondCut.FacetCut({\\n            facetAddress: address(_loupeFacet),\\n            action: IDiamondCut.FacetCutAction.Add,\\n            functionSelectors: loupeSelectors\\n        });\\n\\n        bytes4[] memory EIP712InspectorFacetSelectors = new bytes4[](2);\\n        EIP712InspectorFacetSelectors[0] = EIP712InspectorFacet.inspectEIP712Hashes.selector;\\n        EIP712InspectorFacetSelectors[1] = EIP712InspectorFacet.currentChainId.selector;\\n\\n        facetCuts[1] = IDiamondCut.FacetCut({\\n            facetAddress: address(_inspectorFacet),\\n            action: IDiamondCut.FacetCutAction.Add,\\n            functionSelectors: EIP712InspectorFacetSelectors\\n        });\\n        bytes4[] memory RankifyInstanceMainFacetSelectors = new bytes4[](28);\\n        RankifyInstanceMainFacetSelectors[0] = RankifyInstanceMainFacet.cancelGame.selector;\\n        RankifyInstanceMainFacetSelectors[1] = RankifyInstanceMainFacet.gameCreator.selector;\\n        RankifyInstanceMainFacetSelectors[2] = stringToSelector(\\\"createGame(address,uint256,uint256)\\\");\\n        RankifyInstanceMainFacetSelectors[3] = stringToSelector(\\\"createGame(address,uint256,uint256,address[])\\\");\\n        RankifyInstanceMainFacetSelectors[4] = stringToSelector(\\\"createGame(address,uint256)\\\");\\n        RankifyInstanceMainFacetSelectors[5] = RankifyInstanceMainFacet.leaveGame.selector;\\n        RankifyInstanceMainFacetSelectors[6] = RankifyInstanceMainFacet.joinGame.selector;\\n        RankifyInstanceMainFacetSelectors[7] = RankifyInstanceMainFacet.openRegistration.selector;\\n        RankifyInstanceMainFacetSelectors[8] = RankifyInstanceMainFacet.startGame.selector;\\n        RankifyInstanceMainFacetSelectors[9] = RankifyInstanceMainFacet.onERC1155BatchReceived.selector;\\n        RankifyInstanceMainFacetSelectors[10] = RankifyInstanceMainFacet.onERC1155Received.selector;\\n        RankifyInstanceMainFacetSelectors[11] = RankifyInstanceMainFacet.onERC721Received.selector;\\n        RankifyInstanceMainFacetSelectors[12] = RankifyInstanceMainFacet.getContractState.selector;\\n        RankifyInstanceMainFacetSelectors[13] = RankifyInstanceMainFacet.getTurn.selector;\\n        RankifyInstanceMainFacetSelectors[14] = RankifyInstanceMainFacet.getGM.selector;\\n        RankifyInstanceMainFacetSelectors[15] = RankifyInstanceMainFacet.getScores.selector;\\n        RankifyInstanceMainFacetSelectors[16] = RankifyInstanceMainFacet.isOvertime.selector;\\n        RankifyInstanceMainFacetSelectors[17] = RankifyInstanceMainFacet.isGameOver.selector;\\n        RankifyInstanceMainFacetSelectors[18] = RankifyInstanceMainFacet.getPlayersGame.selector;\\n        RankifyInstanceMainFacetSelectors[19] = RankifyInstanceMainFacet.isLastTurn.selector;\\n        RankifyInstanceMainFacetSelectors[20] = RankifyInstanceMainFacet.isRegistrationOpen.selector;\\n        RankifyInstanceMainFacetSelectors[21] = RankifyInstanceMainFacet.getGameRank.selector;\\n        RankifyInstanceMainFacetSelectors[22] = RankifyInstanceMainFacet.getPlayers.selector;\\n        RankifyInstanceMainFacetSelectors[23] = RankifyInstanceMainFacet.canStartGame.selector;\\n        RankifyInstanceMainFacetSelectors[24] = RankifyInstanceMainFacet.canEndTurn.selector;\\n        RankifyInstanceMainFacetSelectors[25] = RankifyInstanceMainFacet.isPlayerTurnComplete.selector;\\n        RankifyInstanceMainFacetSelectors[26] = RankifyInstanceMainFacet.getPlayerVotedArray.selector;\\n        RankifyInstanceMainFacetSelectors[27] = RankifyInstanceMainFacet.getPlayersMoved.selector;\\n\\n        facetCuts[2] = IDiamondCut.FacetCut({\\n            facetAddress: address(_RankifyMainFacet),\\n            action: IDiamondCut.FacetCutAction.Add,\\n            functionSelectors: RankifyInstanceMainFacetSelectors\\n        });\\n        bytes4[] memory RankifyInstanceRequirementsFacetSelectors = new bytes4[](3);\\n        RankifyInstanceRequirementsFacetSelectors[0] = RankifyInstanceRequirementsFacet.setJoinRequirements.selector;\\n        RankifyInstanceRequirementsFacetSelectors[1] = RankifyInstanceRequirementsFacet.getJoinRequirements.selector;\\n        RankifyInstanceRequirementsFacetSelectors[2] = RankifyInstanceRequirementsFacet\\n            .getJoinRequirementsByToken\\n            .selector;\\n\\n        facetCuts[3] = IDiamondCut.FacetCut({\\n            facetAddress: address(_RankifyReqsFacet),\\n            action: IDiamondCut.FacetCutAction.Add,\\n            functionSelectors: RankifyInstanceRequirementsFacetSelectors\\n        });\\n\\n        bytes4[] memory RankifyInstanceGameMastersFacetSelectors = new bytes4[](3);\\n        RankifyInstanceGameMastersFacetSelectors[0] = RankifyInstanceGameMastersFacet.submitVote.selector;\\n        RankifyInstanceGameMastersFacetSelectors[1] = RankifyInstanceGameMastersFacet.submitProposal.selector;\\n        RankifyInstanceGameMastersFacetSelectors[2] = RankifyInstanceGameMastersFacet.endTurn.selector;\\n\\n        facetCuts[4] = IDiamondCut.FacetCut({\\n            facetAddress: address(_RankifyGMFacet),\\n            action: IDiamondCut.FacetCutAction.Add,\\n            functionSelectors: RankifyInstanceGameMastersFacetSelectors\\n        });\\n\\n        bytes4[] memory RankifyInstanceGameOwnersFacetSelectors = new bytes4[](8);\\n\\n        RankifyInstanceGameOwnersFacetSelectors[0] = RankifyInstanceGameOwnersFacet.setGamePrice.selector;\\n        RankifyInstanceGameOwnersFacetSelectors[1] = RankifyInstanceGameOwnersFacet.setJoinGamePrice.selector;\\n        RankifyInstanceGameOwnersFacetSelectors[2] = RankifyInstanceGameOwnersFacet.setRankTokenAddress.selector;\\n        RankifyInstanceGameOwnersFacetSelectors[3] = RankifyInstanceGameOwnersFacet.setTimePerTurn.selector;\\n        RankifyInstanceGameOwnersFacetSelectors[4] = RankifyInstanceGameOwnersFacet.setMaxPlayersSize.selector;\\n        RankifyInstanceGameOwnersFacetSelectors[5] = RankifyInstanceGameOwnersFacet.setMinPlayersSize.selector;\\n        RankifyInstanceGameOwnersFacetSelectors[6] = RankifyInstanceGameOwnersFacet.setTimeToJoin.selector;\\n        RankifyInstanceGameOwnersFacetSelectors[7] = RankifyInstanceGameOwnersFacet.setMaxTurns.selector;\\n        facetCuts[5] = IDiamondCut.FacetCut({\\n            facetAddress: address(_RankifyOwnerFacet),\\n            action: IDiamondCut.FacetCutAction.Add,\\n            functionSelectors: RankifyInstanceGameOwnersFacetSelectors\\n        });\\n\\n        bytes4[] memory OwnershipFacetSelectors = new bytes4[](2);\\n        OwnershipFacetSelectors[0] = _OwnershipFacet.transferOwnership.selector;\\n        OwnershipFacetSelectors[1] = _OwnershipFacet.owner.selector;\\n\\n        facetCuts[6] = IDiamondCut.FacetCut({\\n            facetAddress: address(_OwnershipFacet),\\n            action: IDiamondCut.FacetCutAction.Add,\\n            functionSelectors: OwnershipFacetSelectors\\n        });\\n        bytes4[] memory initializerSelectors = new bytes4[](1);\\n        initializerSelectors[0] = RankifyInstanceInit.init.selector;\\n        facetCuts[7] = IDiamondCut.FacetCut({\\n            facetAddress: _initializer,\\n            action: IDiamondCut.FacetCutAction.Add,\\n            functionSelectors: initializerSelectors\\n        });\\n\\n        super.initialize(DiamondCutFacet(diamond), facetCuts, \\\"\\\");\\n        address[] memory returnValue = new address[](9);\\n        returnValue[0] = diamond;\\n        returnValue[1] = facetCuts[0].facetAddress;\\n        returnValue[2] = facetCuts[1].facetAddress;\\n        returnValue[3] = facetCuts[2].facetAddress;\\n        returnValue[4] = facetCuts[3].facetAddress;\\n        returnValue[5] = facetCuts[4].facetAddress;\\n        returnValue[6] = facetCuts[5].facetAddress;\\n        returnValue[7] = facetCuts[6].facetAddress;\\n        returnValue[8] = facetCuts[7].facetAddress;\\n\\n        return (returnValue, distributionName, distributionVersion);\\n    }\\n\\n    function contractURI() public pure virtual override returns (string memory) {\\n        return string(abi.encodePacked(super.contractURI(), \\\";\\\", \\\"ArguableVotingTournament\\\"));\\n    }\\n\\n    function sources() internal view virtual override returns (address[] memory, bytes32, uint256) {\\n        (address[] memory srcs, , ) = super.sources();\\n        return (srcs, distributionName, distributionVersion);\\n    }\\n}\\n\",\"keccak256\":\"0x53932cd323f101e7f1c9a7eca991456ebbda34ad7a0633e4b6a7a57a8e0e7729\",\"license\":\"MIT\"},\"src/distributions/DiamondDistribution.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"@peeramid-labs/eds/src/abstracts/CloneDistribution.sol\\\";\\nimport \\\"../vendor/diamond/DiamondCloneable.sol\\\";\\nimport \\\"../vendor/diamond/facets/DiamondCutFacet.sol\\\";\\n\\n/**\\n * @title Diamond Proxy Distribution\\n * @notice This contract is EDS compatible factory for diamond proxies\\n * @dev This uses modified version of Diamond Proxy, which allows proxy itself to cloned\\n * @author Peeramid Labs, 2024\\n */\\ncontract DiamondDistribution is CloneDistribution {\\n    address private immutable _reference;\\n\\n    constructor(address owner) {\\n        address diamondCutFacet = address(new DiamondCutFacet());\\n        // Deploy the diamond proxy contract\\n        address diamondProxy = address(new DiamondCloneable(owner, diamondCutFacet));\\n        _reference = diamondProxy;\\n    }\\n\\n    function instantiate(bytes memory) external virtual override returns (address[] memory, bytes32, uint256) {\\n        return super._instantiate();\\n    }\\n\\n    function sources() internal view virtual override returns (address[] memory, bytes32 name, uint256 version) {\\n        address[] memory _sources = new address[](1);\\n        _sources[0] = _reference;\\n        return (_sources, bytes32(abi.encodePacked(\\\"DiamondDistribution\\\")), uint256(0));\\n    }\\n\\n    function contractURI() public pure virtual override returns (string memory) {\\n        return \\\"\\\";\\n    }\\n}\\n\",\"keccak256\":\"0x4fe445fff5fa9bb2068e78e12a0605a8a784d059bd0a9d94e15ec784fe3a76c5\",\"license\":\"MIT\"},\"src/distributions/InitializedDiamondDistribution.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"../vendor/diamond/DiamondCloneable.sol\\\";\\nimport \\\"../vendor/diamond/facets/DiamondCutFacet.sol\\\";\\nimport \\\"../distributions/DiamondDistribution.sol\\\";\\nimport \\\"../vendor/diamond/libraries/LibDiamond.sol\\\";\\nimport \\\"../vendor/diamond/interfaces/IDiamondCut.sol\\\";\\n\\n/**\\n * @title Initialized Diamond Proxy Distribution\\n * @notice This contract is EDS compatible factory for diamond proxies\\n * @dev This allows to store immutable initializer logic for a cloned diamond proxy\\n * @author Peeramid Labs, 2024\\n */\\nabstract contract InitializedDiamondDistribution is DiamondDistribution {\\n    address private immutable initializer;\\n    bytes4 private immutable initializerSelector;\\n\\n    constructor(address owner, bytes32 _initializerId, bytes4 _initializerSelector) DiamondDistribution(owner) {\\n        initializer = getContractsIndex().get(_initializerId);\\n        initializerSelector = _initializerSelector;\\n    }\\n\\n    function initialize(\\n        DiamondCutFacet instance,\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        bytes memory args\\n    ) internal virtual {\\n        bytes memory _calldata = args.length > 0 ? abi.encodeWithSelector(initializerSelector, args) : bytes(\\\"\\\");\\n        instance.diamondCut(_diamondCut, initializer, _calldata);\\n    }\\n\\n    function get() public view virtual override returns (address[] memory, bytes32 name, uint256 version) {\\n        (address[] memory srcs, , ) = super.sources();\\n        address[] memory _sources = new address[](2);\\n        assert(srcs.length == 1);\\n        _sources[0] = srcs[0];\\n        _sources[1] = initializer;\\n        return (srcs, bytes32(abi.encodePacked(\\\"InitializedDiamondDistribution\\\")), uint256(0));\\n    }\\n\\n    function contractURI() public pure virtual override returns (string memory) {\\n        return string(abi.encodePacked(super.contractURI(), \\\";\\\", \\\"InitializedDiamondDistribution\\\")); //ToDo: Add IPFS link with readme!\\n    }\\n}\\n\",\"keccak256\":\"0x9822b8cca233b2e4d97383b280f6214950c69ad90a48c6bf108b068d38234f0a\",\"license\":\"MIT\"},\"src/facets/EIP712InspectorFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\nimport \\\"../libraries/LibEIP712Storage.sol\\\";\\n\\ncontract EIP712InspectorFacet {\\n    function inspectEIP712Hashes()\\n        public\\n        view\\n        returns (\\n            bytes32 _CACHED_DOMAIN_SEPARATOR,\\n            uint256 _CACHED_CHAIN_ID,\\n            address _CACHED_THIS,\\n            bytes32 _HASHED_NAME,\\n            bytes32 _HASHED_VERSION,\\n            bytes32 _TYPE_HASH\\n        )\\n    {\\n        LibEIP712WithStorage.LibEIP712WithStorageStorage storage ss = LibEIP712WithStorage.EIP712WithStorage();\\n\\n        return (\\n            ss._CACHED_DOMAIN_SEPARATOR,\\n            ss._CACHED_CHAIN_ID,\\n            ss._CACHED_THIS,\\n            ss._HASHED_NAME,\\n            ss._HASHED_VERSION,\\n            ss._TYPE_HASH\\n        );\\n    }\\n\\n    function currentChainId() public view returns (uint256) {\\n        return block.chainid;\\n    }\\n}\\n\",\"keccak256\":\"0x202207c66d9ecddaee47b1de7a59b674ba4180ae7ffe028d4f28480f062a6724\",\"license\":\"MIT\"},\"src/facets/RankifyInstanceGameMastersFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {LibTBG} from \\\"../libraries/LibTurnBasedGame.sol\\\";\\nimport {LibRankify} from \\\"../libraries/LibRankify.sol\\\";\\nimport {IRankifyInstanceCommons} from \\\"../interfaces/IRankifyInstanceCommons.sol\\\";\\nimport \\\"../abstracts/DiamondReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"../abstracts/draft-EIP712Diamond.sol\\\";\\nimport {LibCoinVending} from \\\"../libraries/LibCoinVending.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/interfaces/IERC20.sol\\\";\\nimport \\\"../vendor/diamond/libraries/LibDiamond.sol\\\";\\n\\ncontract RankifyInstanceGameMastersFacet is DiamondReentrancyGuard, EIP712 {\\n    using LibTBG for uint256;\\n    using LibRankify for uint256;\\n    using LibTBG for LibTBG.GameInstance;\\n    event OverTime(uint256 indexed gameId);\\n    event LastTurn(uint256 indexed gameId);\\n    event ProposalScore(\\n        uint256 indexed gameId,\\n        uint256 indexed turn,\\n        string indexed proposalHash,\\n        string proposal,\\n        uint256 score\\n    );\\n    event TurnEnded(\\n        uint256 indexed gameId,\\n        uint256 indexed turn,\\n        address[] players,\\n        uint256[] scores,\\n        string[] newProposals,\\n        uint256[] proposerIndicies,\\n        uint256[][] votes\\n    );\\n\\n    event GameOver(uint256 indexed gameId, address[] players, uint256[] scores);\\n\\n    event ProposalSubmitted(\\n        uint256 indexed gameId,\\n        uint256 indexed turn,\\n        address indexed proposer,\\n        bytes32 commitmentHash,\\n        string proposalEncryptedByGM\\n    );\\n    struct ProposalParams {\\n        uint256 gameId;\\n        string encryptedProposal;\\n        bytes32 commitmentHash;\\n        address proposer;\\n    }\\n\\n    event VoteSubmitted(uint256 indexed gameId, uint256 indexed turn, address indexed player, string votesHidden);\\n\\n    /**\\n     * @dev Handles the end of the game for a player. `gameId` is the ID of the game. `player` is the address of the player.\\n     *\\n     * Modifies:\\n     *\\n     * - Releases the coins for the game with `gameId`, the game creator, the top player, and `player`.\\n     */\\n    function onPlayersGameEnd(uint256 gameId, address player) private {\\n        IRankifyInstanceCommons.RInstance storage game = gameId.getGameStorage();\\n        LibCoinVending.release(bytes32(gameId), game.createdBy, gameId.getLeaderBoard()[0], player);\\n    }\\n\\n    /**\\n     * @dev Submits a vote for a game. `gameId` is the ID of the game. `encryptedVotes` is the encrypted votes. `voter` is the address of the voter.\\n     *\\n     * Emits a _VoteSubmitted_ event.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must be a game master of the game with `gameId`.\\n     * - The game with `gameId` must exist.\\n     * - The game with `gameId` must have started.\\n     * - The game with `gameId` must not be over.\\n     * - `voter` must be in the game with `gameId`.\\n     * - The current turn of the game with `gameId` must be greater than 1.\\n     */\\n    function submitVote(uint256 gameId, string memory encryptedVotes, address voter) public {\\n        LibRankify.enforceIsGM(gameId, msg.sender);\\n        gameId.enforceGameExists();\\n        gameId.enforceHasStarted();\\n        require(!gameId.isGameOver(), \\\"Game over\\\");\\n        gameId.enforceIsPlayingGame(voter);\\n        require(gameId.getTurn() > 1, \\\"No proposals exist at turn 1: cannot vote\\\");\\n        IRankifyInstanceCommons.RInstance storage game = gameId.getGameStorage();\\n        require(!game.playerVoted[voter], \\\"Already voted\\\");\\n        game.numVotesThisTurn += 1;\\n        game.playerVoted[voter] = true;\\n        gameId.tryPlayerMove(voter);\\n        emit VoteSubmitted(gameId, gameId.getTurn(), voter, encryptedVotes);\\n    }\\n\\n    /**\\n     * @dev Submits a proposal for a game. `proposalData` is the proposal data.\\n     *\\n     * Requirements:\\n     *\\n     * - The game with `proposalData.gameId` must exist.\\n     * - The caller must be a game master of the game with `proposalData.gameId`.\\n     */\\n    function submitProposal(ProposalParams memory proposalData) public {\\n        proposalData.gameId.enforceGameExists();\\n        proposalData.gameId.enforceIsGM(msg.sender);\\n        require(!proposalData.gameId.isGameOver(), \\\"Game over\\\");\\n        proposalData.gameId.enforceHasStarted();\\n\\n        IRankifyInstanceCommons.RInstance storage game = proposalData.gameId.getGameStorage();\\n        require(LibTBG.getPlayersGame(proposalData.proposer) == proposalData.gameId, \\\"not a player\\\");\\n        // require(!proposalData.gameId.isLastTurn(), \\\"Cannot propose in last turn\\\");\\n        require(bytes(proposalData.encryptedProposal).length != 0, \\\"Cannot propose empty\\\");\\n        require(game.proposalCommitmentHashes[proposalData.proposer] == \\\"\\\", \\\"Already proposed!\\\");\\n        uint256 turn = proposalData.gameId.getTurn();\\n        game.proposalCommitmentHashes[proposalData.proposer] = proposalData.commitmentHash;\\n        game.numCommitments += 1;\\n        proposalData.gameId.tryPlayerMove(proposalData.proposer);\\n        emit ProposalSubmitted(\\n            proposalData.gameId,\\n            turn,\\n            proposalData.proposer,\\n            proposalData.commitmentHash,\\n            proposalData.encryptedProposal\\n        );\\n    }\\n\\n    /**\\n     * @dev Handles the actions after the next turn of a game with the provided game ID. `gameId` is the ID of the game. `newProposals` is the array of new proposals.\\n     *\\n     * Modifies:\\n     *\\n     * - Sets the ongoing proposals of the game with `gameId` to `newProposals`.\\n     * - Increments the number of ongoing proposals of the game with `gameId` by the number of `newProposals`.\\n     */\\n    function _afterNextTurn(uint256 gameId, string[] memory newProposals) private {\\n        IRankifyInstanceCommons.RInstance storage game = gameId.getGameStorage();\\n        for (uint256 i = 0; i < newProposals.length; ++i) {\\n            game.ongoingProposals[i] = newProposals[i];\\n        }\\n    }\\n\\n    /**\\n     * @dev Handles the next turn of a game with the provided game ID. `gameId` is the ID of the game. `newProposals` is the array of new proposals.\\n     *\\n     * Emits an {OverTime_ event if the game is in the last turn and overtime.\\n     * emits a _LastTurn_ event if the game is in the last turn.\\n     * emits a _GameOver_ event if the game is over.\\n     *\\n     * Modifies:\\n     *\\n     * - Calls the `_afterNextTurn` function with `gameId` and `newProposals`.\\n     */\\n    function _nextTurn(uint256 gameId, string[] memory newProposals) private {\\n        (bool _isLastTurn, bool _isOvertime, bool _isGameOver) = gameId.nextTurn();\\n        if (_isLastTurn && _isOvertime) {\\n            emit OverTime(gameId);\\n        }\\n        if (_isLastTurn) {\\n            emit LastTurn(gameId);\\n        }\\n        if (_isGameOver) {\\n            uint256[] memory finalScores = gameId.closeGame(LibDiamond.contractOwner(), onPlayersGameEnd);\\n            address[] memory players = gameId.getPlayers();\\n            emit GameOver(gameId, players, finalScores);\\n        }\\n        _afterNextTurn(gameId, newProposals);\\n    }\\n\\n    /**\\n     * @dev Ends the current turn of a game with the provided game ID. `gameId` is the ID of the game. `votes` is the array of votes.\\n     *  `newProposals` is the array of new proposals for the upcoming voting round.\\n     *  `proposerIndicies` is the array of indices of the proposers in the previous voting round.\\n     *\\n     * emits a _ProposalScore_ event for each player if the turn is not the first.\\n     * emits a _TurnEnded_ event.\\n     *\\n     * Modifies:\\n     *\\n     * - Calls the `_nextTurn` function with `gameId` and `newProposals`.\\n     * - Resets the number of commitments of the game with `gameId` to 0.\\n     * - Resets the proposal commitment hash and ongoing proposal of each player in the game with `gameId`.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must be a game master of the game with `gameId`.\\n     * - The game with `gameId` must have started.\\n     * - The game with `gameId` must not be over.\\n     * -  newProposals array MUST be sorted randomly to ensure privacy\\n     * votes and proposerIndicies MUST correspond to players array from game.getPlayers()\\n     */\\n    function endTurn(\\n        uint256 gameId,\\n        uint256[][] memory votes,\\n        string[] memory newProposals, //REFERRING TO UPCOMING VOTING ROUND\\n        uint256[] memory proposerIndicies //REFERRING TO game.players index in PREVIOUS VOTING ROUND\\n    ) public {\\n        gameId.enforceIsGM(msg.sender);\\n        gameId.enforceHasStarted();\\n        gameId.enforceIsNotOver();\\n        IRankifyInstanceCommons.RInstance storage game = gameId.getGameStorage();\\n        uint256 turn = gameId.getTurn();\\n\\n        address[] memory players = gameId.getPlayers();\\n        if (turn != 1) {\\n            uint256[][] memory votesSorted = new uint256[][](players.length);\\n            for (uint256 player = 0; player < players.length; ++player) {\\n                votesSorted[player] = new uint256[](players.length);\\n            }\\n            for (uint256 votee = 0; votee < players.length; ++votee) {\\n                uint256 voteesColumn = proposerIndicies[votee];\\n                if (voteesColumn < players.length) {\\n                    // if index is above length of players array, it means the player did not propose\\n                    for (uint256 voter = 0; voter < players.length; voter++) {\\n                        votesSorted[voter][votee] = votes[voter][voteesColumn];\\n                    }\\n                }\\n            }\\n\\n            (, uint256[] memory roundScores) = gameId.calculateScoresQuadratic(votesSorted, proposerIndicies);\\n            for (uint256 i = 0; i < players.length; ++i) {\\n                string memory proposal = game.ongoingProposals[proposerIndicies[i]];\\n                emit ProposalScore(gameId, turn, proposal, proposal, roundScores[i]);\\n            }\\n        }\\n        (, uint256[] memory scores) = gameId.getScores();\\n        emit TurnEnded(gameId, gameId.getTurn(), players, scores, newProposals, proposerIndicies, votes);\\n\\n        // Clean up game instance for upcoming round\\n\\n        for (uint256 i = 0; i < players.length; ++i) {\\n            game.proposalCommitmentHashes[players[i]] = bytes32(0);\\n            game.ongoingProposals[i] = \\\"\\\";\\n            game.playerVoted[players[i]] = false;\\n            game.votesHidden[players[i]].hash = bytes32(0);\\n        }\\n        // This data is to needed to correctly detetermine \\\"PlayerMove\\\" conditions during next turn\\n        game.numVotesPrevTurn = game.numVotesThisTurn;\\n        game.numVotesThisTurn = 0;\\n        game.numPrevProposals = game.numCommitments;\\n        game.numCommitments = 0;\\n\\n        _nextTurn(gameId, newProposals);\\n    }\\n}\\n\",\"keccak256\":\"0xc8b8a13b87fd4a989c598455003c6ef5d86f9d4604f57d9f3ca5dc1a61d7ffca\",\"license\":\"MIT\"},\"src/facets/RankifyInstanceGameOwnersFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {LibTBG} from \\\"../libraries/LibTurnBasedGame.sol\\\";\\nimport {IRankifyInstanceCommons} from \\\"../interfaces/IRankifyInstanceCommons.sol\\\";\\n\\nimport \\\"../abstracts/draft-EIP712Diamond.sol\\\";\\nimport \\\"../vendor/diamond/libraries/LibDiamond.sol\\\";\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {ERC165Checker} from \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\n\\nerror ZeroValue();\\nerror WrongAddress();\\nerror OutOfBounds();\\n\\ncontract RankifyInstanceGameOwnersFacet {\\n    using LibTBG for LibTBG.GameInstance;\\n    using LibTBG for uint256;\\n    using LibTBG for LibTBG.GameSettings;\\n\\n    function RInstanceStorage() internal pure returns (IRankifyInstanceCommons.RInstanceSettings storage bog) {\\n        bytes32 position = LibTBG.getDataStorage();\\n        assembly {\\n            bog.slot := position\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets the game price. `newPrice` is the new game price.\\n     *\\n     * Modifies:\\n     *\\n     * - Sets the game price to `newPrice`.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must be the contract owner.\\n     */\\n    function setGamePrice(uint256 newPrice) external {\\n        LibDiamond.enforceIsContractOwner();\\n        IRankifyInstanceCommons.RInstanceSettings storage _RInstance = RInstanceStorage();\\n        _RInstance.gamePrice = newPrice;\\n    }\\n\\n    /**\\n     * @dev Sets the join game price. `newPrice` is the new join game price.\\n     *\\n     * Modifies:\\n     *\\n     * - Sets the join game price to `newPrice`.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must be the contract owner.\\n     */\\n    function setJoinGamePrice(uint256 newPrice) external {\\n        LibDiamond.enforceIsContractOwner();\\n        IRankifyInstanceCommons.RInstanceSettings storage _RInstance = RInstanceStorage();\\n        _RInstance.joinGamePrice = newPrice;\\n    }\\n\\n    /**\\n     * @dev Sets the rank token address. `newRankToken` is the new rank token address.\\n     *\\n     * Modifies:\\n     *\\n     * - Sets the rank token address to `newRankToken`.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must be the contract owner.\\n     * - `newRankToken` must not be the zero address.\\n     * - `newRankToken` must support the ERC1155 interface.\\n     */\\n    function setRankTokenAddress(address newRankToken) external {\\n        LibDiamond.enforceIsContractOwner();\\n        if (newRankToken == address(0)) {\\n            require(false, \\\"zerovalue\\\"); //revert ZeroValue();\\n        }\\n        if (!ERC165Checker.supportsInterface(newRankToken, type(IERC1155).interfaceId)) {\\n            require(false, \\\"wrongaddress\\\"); //revert WrongAddress();\\n        }\\n\\n        IRankifyInstanceCommons.RInstanceSettings storage _RInstance = RInstanceStorage();\\n        _RInstance.rankTokenAddress = newRankToken;\\n    }\\n\\n    /**\\n     *\\n     * @dev Sets the payment token address.\\n     * Requirements:\\n     *\\n     * - The caller must be the contract owner.\\n     * - `newPaymentToken` must not be the zero address.\\n     * - `newRankToken` must support the ERC20 interface.\\n     */\\n    function setPaymentTokenAddress(address newPaymentToken) external {\\n        LibDiamond.enforceIsContractOwner();\\n        if (newPaymentToken == address(0)) {\\n            require(false, \\\"zerovalue\\\"); //revert ZeroValue();\\n        }\\n        if (!ERC165Checker.supportsInterface(newPaymentToken, type(IERC20).interfaceId)) {\\n            require(false, \\\"wrongaddress\\\"); //revert WrongAddress();\\n        }\\n        IRankifyInstanceCommons.RInstanceSettings storage _RInstance = RInstanceStorage();\\n        _RInstance.gamePaymentToken = newPaymentToken;\\n    }\\n\\n    /**\\n     * @dev Sets the time per turn. `newTimePerTurn` is the new time per turn.\\n     *\\n     * Modifies:\\n     *\\n     * - Sets the time per turn to `newTimePerTurn`.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must be the contract owner.\\n     */\\n    function setTimePerTurn(uint256 newTimePerTurn) external {\\n        LibDiamond.enforceIsContractOwner();\\n        if (newTimePerTurn == 0) {\\n            require(false, \\\"zerovalue\\\"); // revert ZeroValue();\\n        }\\n        LibTBG.TBGStorageStruct storage tbg = LibTBG.TBGStorage();\\n        tbg.settings.timePerTurn = newTimePerTurn;\\n    }\\n\\n    /**\\n     * @dev Sets the maximum number of players in a game. `newMaxPlayersSize` is the new maximum number of players.\\n     *\\n     * Modifies:\\n     *\\n     * - Sets the maximum number of players to `newMaxPlayersSize`.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must be the contract owner.\\n     * - `newMaxPlayersSize` must be greater than or equal to the minimum number of players.\\n     */\\n    function setMaxPlayersSize(uint256 newMaxPlayersSize) external {\\n        LibDiamond.enforceIsContractOwner();\\n        LibTBG.TBGStorageStruct storage tbg = LibTBG.TBGStorage();\\n        if (newMaxPlayersSize < tbg.settings.minPlayersSize) {\\n            require(false, \\\"outofbonds\\\"); // revert OutOfBounds();\\n        }\\n        tbg.settings.maxPlayersSize = newMaxPlayersSize;\\n    }\\n\\n    /**\\n     * @dev Sets the minimum number of players in a game. `newMinPlayersSize` is the new minimum number of players.\\n     *\\n     * Modifies:\\n     *\\n     * - Sets the minimum number of players to `newMinPlayersSize`.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must be the contract owner.\\n     * - `newMinPlayersSize` must be less than or equal to the maximum number of players.\\n     */\\n    function setMinPlayersSize(uint256 newMinPlayersSize) external {\\n        LibDiamond.enforceIsContractOwner();\\n        LibTBG.TBGStorageStruct storage tbg = LibTBG.TBGStorage();\\n        if (newMinPlayersSize > tbg.settings.maxPlayersSize) {\\n            require(false, \\\"outofbonds\\\"); // revert OutOfBounds();\\n        }\\n        tbg.settings.minPlayersSize = newMinPlayersSize;\\n    }\\n\\n    /**\\n     * @dev Sets the time to join a game. `newTimeToJoin` is the new time to join.\\n     *\\n     * Modifies:\\n     *\\n     * - Sets the time to join to `newTimeToJoin`.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must be the contract owner.\\n     * - `newTimeToJoin` must not be zero.\\n     */\\n    function setTimeToJoin(uint256 newTimeToJoin) external {\\n        LibDiamond.enforceIsContractOwner();\\n        if (newTimeToJoin == 0) {\\n            require(false, \\\"ZeroValue\\\"); //revert ZeroValue();\\n        }\\n        LibTBG.TBGStorageStruct storage tbg = LibTBG.TBGStorage();\\n        tbg.settings.timeToJoin = newTimeToJoin;\\n    }\\n\\n    /**\\n     * @dev Sets the maximum number of turns in a game. `newMaxTurns` is the new maximum number of turns.\\n     *\\n     * Modifies:\\n     *\\n     * - Sets the maximum number of turns to `newMaxTurns`.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must be the contract owner.\\n     * - `newMaxTurns` must not be zero.\\n     */\\n    function setMaxTurns(uint256 newMaxTurns) external {\\n        LibDiamond.enforceIsContractOwner();\\n        if (newMaxTurns == 0) {\\n            require(false, \\\"ZeroValue\\\"); // revert ZeroValue();\\n        }\\n        LibTBG.TBGStorageStruct storage tbg = LibTBG.TBGStorage();\\n        tbg.settings.maxTurns = newMaxTurns;\\n    }\\n}\\n\",\"keccak256\":\"0x9b965c0d64bbc48b398d5ac7ba27cfe650d20a18cac4126e3cbadd0defc47524\",\"license\":\"MIT\"},\"src/facets/RankifyInstanceMainFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {LibTBG} from \\\"../libraries/LibTurnBasedGame.sol\\\";\\nimport {IRankifyInstanceCommons} from \\\"../interfaces/IRankifyInstanceCommons.sol\\\";\\n\\nimport {IERC1155Receiver} from \\\"../interfaces/IERC1155Receiver.sol\\\";\\nimport {IERC721Receiver} from \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport \\\"../abstracts/DiamondReentrancyGuard.sol\\\";\\nimport {LibRankify} from \\\"../libraries/LibRankify.sol\\\";\\nimport {LibCoinVending} from \\\"../libraries/LibCoinVending.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"../abstracts/draft-EIP712Diamond.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\ncontract RankifyInstanceMainFacet is\\n    IRankifyInstanceCommons,\\n    IERC1155Receiver,\\n    DiamondReentrancyGuard,\\n    IERC721Receiver,\\n    EIP712\\n{\\n    using LibTBG for LibTBG.GameInstance;\\n    using LibTBG for uint256;\\n    using LibTBG for LibTBG.GameSettings;\\n    using LibRankify for uint256;\\n\\n    function RInstanceStorage() internal pure returns (RInstanceSettings storage bog) {\\n        bytes32 position = LibTBG.getDataStorage();\\n        assembly {\\n            bog.slot := position\\n        }\\n    }\\n\\n    /**\\n     * @dev Creates a new game with the provided game master, game ID, and game rank. Optionally, additional ranks can be provided. `gameMaster` is the address of the game master. `gameId` is the ID of the new game. `gameRank` is the rank of the new game. `additionalRanks` is the array of additional ranks.\\n     *\\n     * emits a _GameCreated_ event.\\n     *\\n     * Requirements:\\n     *  There are some game price requirments that must be met under gameId.newGame function that are set during the contract initialization and refer to the contract maintainer benefits.\\n     *\\n     * Modifies:\\n     *\\n     * - Calls the `newGame` function with `gameMaster`, `gameRank`, and `msg.sender`.\\n     * - Configures the coin vending with `gameId` and an empty configuration.\\n     * - If `additionalRanks` is not empty, mints rank tokens for each additional rank and sets the additional ranks of the game with `gameId` to `additionalRanks`.\\n     */\\n    function createGame(address gameMaster, uint256 gameId, uint256 gameRank) public nonReentrant {\\n        gameId.newGame(gameMaster, gameRank, msg.sender);\\n        LibCoinVending.ConfigPosition memory emptyConfig;\\n        LibCoinVending.configure(bytes32(gameId), emptyConfig);\\n        emit gameCreated(gameId, gameMaster, msg.sender, gameRank);\\n    }\\n\\n    function createGame(address gameMaster, uint256 gameRank) public {\\n        LibRankify.enforceIsInitialized();\\n        RInstanceSettings storage settings = RInstanceStorage();\\n        createGame(gameMaster, settings.numGames + 1, gameRank);\\n    }\\n\\n    /**\\n     * @dev Handles a player quitting a game with the provided game ID. `gameId` is the ID of the game. `player` is the address of the player.\\n     *\\n     * emits a _PlayerLeft_ event.\\n     *\\n     * Modifies:\\n     *\\n     * - Refunds the coins for `player` in the game with `gameId`.\\n     */\\n    function onPlayerQuit(uint256 gameId, address player) private {\\n        LibCoinVending.refund(bytes32(gameId), player);\\n        emit PlayerLeft(gameId, player);\\n    }\\n\\n    /**\\n     * @dev Cancels a game with the provided game ID. `gameId` is the ID of the game.\\n     *\\n     * Modifies:\\n     *\\n     * - Calls the `enforceIsGameCreator` function with `msg.sender`.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must be the game creator of the game with `gameId`.\\n     * - Game must not be started.\\n     */\\n    function cancelGame(uint256 gameId) public nonReentrant {\\n        gameId.enforceIsGameCreator(msg.sender);\\n        gameId.cancelGame(onPlayerQuit, LibDiamond.contractOwner());\\n        emit GameClosed(gameId);\\n    }\\n\\n    /**\\n     * @dev Allows a player to leave a game with the provided game ID. `gameId` is the ID of the game.\\n     *\\n     * Modifies:\\n     *\\n     * - Calls the `quitGame` function with `msg.sender`, `true`, and `onPlayerQuit`.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must be a player in the game with `gameId`.\\n     * - Game must not be started.\\n     */\\n    function leaveGame(uint256 gameId) public nonReentrant {\\n        gameId.quitGame(msg.sender, true, onPlayerQuit);\\n    }\\n\\n    /**\\n     * @dev Opens registration for a game with the provided game ID. `gameId` is the ID of the game.\\n     *\\n     * emits a _RegistrationOpen_ event.\\n     *\\n     * Modifies:\\n     *\\n     * - Calls the `enforceIsGameCreator` function with `msg.sender`.\\n     * - Calls the `enforceIsPreRegistrationStage` function.\\n     * - Calls the `openRegistration` function.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must be the game creator of the game with `gameId`.\\n     * - The game with `gameId` must be in the pre-registration stage.\\n     */\\n    function openRegistration(uint256 gameId) public {\\n        gameId.enforceIsGameCreator(msg.sender);\\n        gameId.enforceIsPreRegistrationStage();\\n        gameId.openRegistration();\\n        emit RegistrationOpen(gameId);\\n    }\\n\\n    /**\\n     * @dev Allows a player to join a game with the provided game ID. `gameId` is the ID of the game.\\n     *\\n     * emits a _PlayerJoined_ event.\\n     *\\n     * Modifies:\\n     *\\n     * - Calls the `joinGame` function with `msg.sender`.\\n     * - Calls the `fund` function with `bytes32(gameId)`.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must not be a player in the game with `gameId`.\\n     * - Game phase must be registration.\\n     * - Caller must be able to fulfill funding requirements.\\n     */\\n    function joinGame(uint256 gameId) public payable nonReentrant {\\n        gameId.joinGame(msg.sender);\\n        LibCoinVending.fund(bytes32(gameId));\\n        emit PlayerJoined(gameId, msg.sender);\\n    }\\n\\n    /**\\n     * @dev Starts a game with the provided game ID early. `gameId` is the ID of the game.\\n     *\\n     * emits a _GameStarted_ event.\\n     *\\n     * Modifies:\\n     *\\n     * - Calls the `enforceGameExists` function.\\n     * - Calls the `startGameEarly` function.\\n     *\\n     * Requirements:\\n     *\\n     * - The game with `gameId` must exist.\\n     */\\n    function startGame(uint256 gameId) public {\\n        gameId.enforceGameExists();\\n        gameId.startGameEarly();\\n        emit GameStarted(gameId);\\n    }\\n\\n    function onERC1155Received(\\n        address operator,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) public view override returns (bytes4) {\\n        LibRankify.enforceIsInitialized();\\n        if (operator == address(this)) {\\n            return bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"));\\n        }\\n        return bytes4(\\\"\\\");\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address,\\n        uint256[] calldata,\\n        uint256[] calldata,\\n        bytes calldata\\n    ) external view override returns (bytes4) {\\n        LibRankify.enforceIsInitialized();\\n        if (operator == address(this)) {\\n            return bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"));\\n        }\\n        return bytes4(\\\"\\\");\\n    }\\n\\n    function onERC721Received(\\n        address operator,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external view override returns (bytes4) {\\n        LibRankify.enforceIsInitialized();\\n        if (operator == address(this)) {\\n            return IERC721Receiver.onERC721Received.selector;\\n        }\\n        return bytes4(\\\"\\\");\\n    }\\n\\n    function getContractState() public view returns (RInstanceState memory) {\\n        RInstanceSettings storage settings = RInstanceStorage();\\n        LibTBG.GameSettings memory tbgSettings = LibTBG.getGameSettings();\\n        return (RInstanceState({BestOfState: settings, TBGSEttings: tbgSettings}));\\n    }\\n\\n    function getTurn(uint256 gameId) public view returns (uint256) {\\n        return gameId.getTurn();\\n    }\\n\\n    function getGM(uint256 gameId) public view returns (address) {\\n        return gameId.getGM();\\n    }\\n\\n    function getScores(uint256 gameId) public view returns (address[] memory, uint256[] memory) {\\n        return gameId.getScores();\\n    }\\n\\n    function isOvertime(uint256 gameId) public view returns (bool) {\\n        return gameId.isOvertime();\\n    }\\n\\n    function isGameOver(uint256 gameId) public view returns (bool) {\\n        return gameId.isGameOver();\\n    }\\n\\n    function getPlayersGame(address player) public view returns (uint256) {\\n        return LibTBG.getPlayersGame(player);\\n    }\\n\\n    function isLastTurn(uint256 gameId) public view returns (bool) {\\n        return gameId.isLastTurn();\\n    }\\n\\n    function isRegistrationOpen(uint256 gameId) public view returns (bool) {\\n        return gameId.isRegistrationOpen();\\n    }\\n\\n    function gameCreator(uint256 gameId) public view returns (address) {\\n        return gameId.getGameStorage().createdBy;\\n    }\\n\\n    function getGameRank(uint256 gameId) public view returns (uint256) {\\n        return gameId.getGameStorage().rank;\\n    }\\n\\n    function getPlayers(uint256 gameId) public view returns (address[] memory) {\\n        return gameId.getPlayers();\\n    }\\n\\n    function canStartGame(uint256 gameId) public view returns (bool) {\\n        return gameId.canStartEarly();\\n    }\\n\\n    function canEndTurn(uint256 gameId) public view returns (bool) {\\n        return gameId.canEndTurnEarly();\\n    }\\n\\n    function isPlayerTurnComplete(uint256 gameId, address player) public view returns (bool) {\\n        return gameId.isPlayerTurnComplete(player);\\n    }\\n\\n    function getPlayerVotedArray(uint256 gameId) public view returns (bool[] memory) {\\n        IRankifyInstanceCommons.RInstance storage game = gameId.getGameStorage();\\n        address[] memory players = gameId.getPlayers();\\n        bool[] memory playerVoted = new bool[](players.length);\\n        for (uint256 i = 0; i < players.length; ++i) {\\n            playerVoted[i] = game.playerVoted[players[i]];\\n        }\\n        return playerVoted;\\n    }\\n\\n    function getPlayersMoved(uint256 gameId) public view returns (bool[] memory, uint256) {\\n        LibTBG.GameInstance storage game = gameId._getGame();\\n        address[] memory players = gameId.getPlayers();\\n        bool[] memory playersMoved = new bool[](players.length);\\n        for (uint256 i = 0; i < players.length; ++i) {\\n            playersMoved[i] = game.madeMove[players[i]];\\n        }\\n        return (playersMoved, game.numPlayersMadeMove);\\n    }\\n}\\n\",\"keccak256\":\"0x546d3adba4bde0aeaf2b3ea20dec975c1be53742bcda4ce8fa8bd0ccda69b7bc\",\"license\":\"MIT\"},\"src/facets/RankifyInstanceRequirementsFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {LibTBG} from \\\"../libraries/LibTurnBasedGame.sol\\\";\\nimport {LibCoinVending} from \\\"../libraries/LibCoinVending.sol\\\";\\nimport {LibRankify} from \\\"../libraries/LibRankify.sol\\\";\\n\\ncontract RankifyInstanceRequirementsFacet {\\n    using LibTBG for uint256;\\n    using LibRankify for uint256;\\n    using LibTBG for LibTBG.GameInstance;\\n    event RequirementsConfigured(uint256 indexed gameId, LibCoinVending.ConfigPosition config);\\n\\n    /**\\n     * @dev Sets the join requirements for a specific game.\\n     * Only the game creator can call this function.\\n     * The game must be in the pre-registration stage.\\n     *\\n     * @param gameId The ID of the game.\\n     * @param config The configuration position for the join requirements.\\n     */\\n    function setJoinRequirements(uint256 gameId, LibCoinVending.ConfigPosition memory config) public {\\n        gameId.enforceIsGameCreator(msg.sender);\\n        gameId.enforceIsPreRegistrationStage();\\n        LibCoinVending.configure(bytes32(gameId), config);\\n        emit RequirementsConfigured(gameId, config);\\n    }\\n\\n    /**\\n     * @dev Retrieves the join requirements for a specific game.\\n     * @param gameId The ID of the game.\\n     * @return The join requirements as a `LibCoinVending.ConditionReturn` struct.\\n     */\\n    function getJoinRequirements(uint256 gameId) public view returns (LibCoinVending.ConditionReturn memory) {\\n        return LibCoinVending.getPosition(bytes32(gameId));\\n    }\\n\\n    /**\\n     * @dev Retrieves the join requirements for a specific token in a game.\\n     * @param gameId The ID of the game.\\n     * @param contractAddress The address of the contract.\\n     * @param contractId The ID of the contract.\\n     * @param contractType The type of the contract.\\n     * @return The join requirements for the specified token.\\n     */\\n    function getJoinRequirementsByToken(\\n        uint256 gameId,\\n        address contractAddress,\\n        uint256 contractId,\\n        LibCoinVending.ContractTypes contractType\\n    ) public view returns (LibCoinVending.ContractCondition memory) {\\n        return LibCoinVending.getPositionByContract(bytes32(gameId), contractAddress, contractId, contractType);\\n    }\\n}\\n\",\"keccak256\":\"0x2324a94d8991f782e3e0458d6c41a4ad88a7e64c98968c01bb1704e1d7204ea6\",\"license\":\"MIT\"},\"src/initializers/RankifyInstanceInit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n*\\n* Implementation of a diamond.\\n/******************************************************************************/\\n\\nimport {LibDiamond} from \\\"../vendor/diamond/libraries/LibDiamond.sol\\\";\\nimport {IDiamondLoupe} from \\\"../vendor/diamond/interfaces/IDiamondLoupe.sol\\\";\\nimport {IDiamondCut} from \\\"../vendor/diamond/interfaces/IDiamondCut.sol\\\";\\nimport {IERC173} from \\\"../vendor/diamond/interfaces/IERC173.sol\\\";\\nimport {IERC165} from \\\"../vendor/diamond/interfaces/IERC165.sol\\\";\\nimport {LibEIP712WithStorage} from \\\"../libraries/LibEIP712Storage.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport {IRankifyInstanceCommons} from \\\"../interfaces/IRankifyInstanceCommons.sol\\\";\\nimport {IRankToken} from \\\"../interfaces/IRankToken.sol\\\";\\nimport {LibTBG} from \\\"../libraries/LibTurnBasedGame.sol\\\";\\nimport {LibQuadraticVoting} from \\\"../libraries/LibQuadraticVoting.sol\\\";\\nimport {Initializable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\n// import {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\n// It is expected that this contract is customized if you want to deploy your diamond\\n// with data from a deployment script. Use the init function to initialize state variables\\n// of your diamond. Add parameters to the init funciton if you need to.\\n\\ncontract RankifyInstanceInit is Initializable {\\n    function _buildDomainSeparator(\\n        bytes32 typeHash,\\n        bytes32 nameHash,\\n        bytes32 versionHash\\n    ) private view returns (bytes32) {\\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\\n    }\\n\\n    function RInstanceStorage() internal pure returns (IRankifyInstanceCommons.RInstanceSettings storage bog) {\\n        bytes32 position = LibTBG.getDataStorage();\\n        assembly {\\n            bog.slot := position\\n        }\\n    }\\n\\n    struct contractInitializer {\\n        uint256 timePerTurn;\\n        uint256 maxPlayersSize;\\n        uint256 minPlayersSize;\\n        address rewardToken;\\n        uint256 timeToJoin;\\n        uint256 gamePrice;\\n        uint256 joinGamePrice;\\n        uint256 maxTurns;\\n        uint256 numWinners;\\n        uint256 voteCredits;\\n        address paymentToken;\\n    }\\n\\n    // You can add parameters to this function in order to pass in\\n    // data to set your own state variables\\n    function init(string memory name, string memory version, contractInitializer memory initData) external initializer {\\n        // adding ERC165 data\\n        // LibDiamond.enforceIsContractOwner();\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\\n        ds.supportedInterfaces[type(IERC173).interfaceId] = true;\\n        bytes32 hashedName = keccak256(bytes(name));\\n        bytes32 hashedVersion = keccak256(bytes(version));\\n        bytes32 typeHash = keccak256(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        );\\n        LibEIP712WithStorage.LibEIP712WithStorageStorage storage ss = LibEIP712WithStorage.EIP712WithStorage();\\n        ss._HASHED_NAME = hashedName;\\n        ss._HASHED_VERSION = hashedVersion;\\n        ss._CACHED_CHAIN_ID = block.chainid;\\n        ss._CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\\n        ss._CACHED_THIS = address(this);\\n        ss._TYPE_HASH = typeHash;\\n\\n        IRankifyInstanceCommons.RInstanceSettings storage _RInstance = RInstanceStorage();\\n        _RInstance.voting = LibQuadraticVoting.precomputeValues(initData.voteCredits, initData.minPlayersSize);\\n        _RInstance.gamePrice = initData.gamePrice;\\n        _RInstance.joinGamePrice = initData.joinGamePrice;\\n        require(initData.paymentToken != address(0), \\\"initializer.paymentToken not set\\\");\\n        _RInstance.gamePaymentToken = initData.paymentToken;\\n        IRankToken rankContract = IRankToken(initData.rewardToken);\\n        require(\\n            rankContract.supportsInterface(type(IRankToken).interfaceId),\\n            \\\"RankifyInstance->init: rank token address does not support Rank interface\\\"\\n        );\\n        _RInstance.rankTokenAddress = initData.rewardToken;\\n        _RInstance.contractInitialized = true;\\n\\n        LibTBG.GameSettings memory settings;\\n        settings.timePerTurn = initData.timePerTurn;\\n        settings.maxPlayersSize = initData.maxPlayersSize;\\n        settings.minPlayersSize = initData.minPlayersSize;\\n        settings.timeToJoin = initData.timeToJoin;\\n        settings.maxTurns = initData.maxTurns;\\n        settings.numWinners = initData.numWinners;\\n        LibTBG.init(settings);\\n\\n        // add your own state variables\\n        // EIP-2535 specifies that the `diamondCut` function takes two optional\\n        // arguments: address _init and bytes calldata _calldata\\n        // These arguments are used to execute an arbitrary function using delegatecall\\n        // in order to set state variables in the diamond during deployment or an upgrade\\n        // More info here: https://eips.ethereum.org/EIPS/eip-2535#diamond-interface\\n    }\\n}\\n\",\"keccak256\":\"0x50e18ff6798ff3ac05b8cf3094628236202324c427d45ac9c070255ebe650c6a\",\"license\":\"MIT\"},\"src/interfaces/IERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title ERC1155 transfer receiver interface\\n */\\ninterface IERC1155Receiver {\\n    /**\\n     * @notice validate receipt of ERC1155 transfer\\n     * @param operator executor of transfer\\n     * @param from sender of tokens\\n     * @param id token ID received\\n     * @param value quantity of tokens received\\n     * @param data data payload\\n     * @return function's own selector if transfer is accepted\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @notice validate receipt of ERC1155 batch transfer\\n     * @param operator executor of transfer\\n     * @param from sender of tokens\\n     * @param ids token IDs received\\n     * @param values quantities of tokens received\\n     * @param data data payload\\n     * @return function's own selector if transfer is accepted\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xa27ad77bced0575dc3a3e4eb8f334a4889f16e5cae2053272676ff69ca9379e2\",\"license\":\"MIT\"},\"src/interfaces/ILockableERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {IERC1155} from \\\"@openzeppelin/contracts/interfaces/IERC1155.sol\\\";\\n\\n/**\\n * @title ILockableERC1155\\n * @dev Interface for a lockable ERC1155 token contract.\\n */\\ninterface ILockableERC1155 is IERC1155 {\\n    error insufficient(uint256 id, uint256 balance, uint256 required);\\n\\n    event TokensLocked(address indexed account, uint256 indexed id, uint256 value);\\n\\n    event TokensUnlocked(address indexed account, uint256 indexed id, uint256 value);\\n\\n    /**\\n     * @dev Locks a specified amount of tokens for a given account and token ID. `account` is the address of the account to lock the tokens for. `id` is the ID of the token to lock. `amount` is the amount of tokens to lock.\\n     *\\n     * emits a _TokensLocked_ event.\\n     */\\n    function lock(address account, uint256 id, uint256 amount) external;\\n\\n    /**\\n     * @dev Unlocks a specified amount of tokens for a given account and token ID. `account` is the address of the account to unlock the tokens for. `id` is the ID of the token to unlock. `amount` is the amount of tokens to unlock.\\n     *\\n     * emits a _TokensUnlocked_ event.\\n     */\\n    function unlock(address account, uint256 id, uint256 amount) external;\\n\\n    /**\\n     * @dev Returns the unlocked balance of tokens for a given account and token ID. `account` is the address of the account to check the unlocked balance for. `id` is the ID of the token to check the unlocked balance for.\\n     *\\n     * Returns:\\n     *\\n     * - The unlocked balance of tokens.\\n     */\\n    function unlockedBalanceOf(address account, uint256 id) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xea42e12b3d90291b4d9873ae4a05dd682f62878328210a578ce092eb31b2844a\",\"license\":\"MIT\"},\"src/interfaces/IRankToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {ILockableERC1155} from \\\"./ILockableERC1155.sol\\\";\\n\\ninterface IRankToken is ILockableERC1155 {\\n    event RankingInstanceUpdated(address indexed newRankingInstance);\\n\\n    // event LevelUp(address indexed account, uint256 id);\\n\\n    /**\\n     * @dev Mints a specified amount of tokens to an account. `to` is the address of the account to mint the tokens to. `amount` is the amount of tokens to mint. `poolId` is the ID of the pool. `data` is the additional data.\\n     */\\n    function mint(address to, uint256 amount, uint256 poolId, bytes memory data) external;\\n\\n    /**\\n     * @dev Mints specified amounts of tokens to an account. `to` is the address of the account to mint the tokens to. `ids` is the array of IDs of the tokens to mint. `amounts` is the array of amounts of tokens to mint. `data` is the additional data.\\n     */\\n    function batchMint(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) external;\\n\\n    // /**\\n    //  * @dev Updates the ranking instance. `newRankingInstance` is the address of the new ranking instance.\\n    //  *\\n    //  * emits a _RankingInstanceUpdated_ event.\\n    //  */\\n    // function updateRankingInstance(address newRankingInstance) external;\\n\\n    /**\\n     * @dev Gets the ranking instance which can emit new rank updates and mint rank tokens.\\n     *\\n     * Returns:\\n     *\\n     * - The address of the ranking instance.\\n     */\\n    // function getRankingInstance() external view returns (address);\\n\\n    // /**\\n    //  * @dev Finds the new rank of an account. `account` is the address of the account. `oldRank` is the old rank of the account.\\n    //  * It checks the balance of the account and returns the new rank that can be upgraded to.\\n    //  *\\n    //  * Returns:\\n    //  *\\n    //  * - The new rank of the account.\\n    //  */\\n    // function findNewRank(address account, uint256 oldRank) external view returns (uint256);\\n\\n    // /**\\n    //  * @dev Gets the rank of an account. `account` is the address of the account.\\n    //  *\\n    //  * Returns:\\n    //  *\\n    //  * - The rank of the account.\\n    //  */\\n    // function getAccountRank(address account) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xb21a5ffaf22d264802b6615c579e41eff9a331a48b085acedfd935f97733c5c7\",\"license\":\"MIT\"},\"src/interfaces/IRankifyInstanceCommons.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport {LibTBG} from \\\"../libraries/LibTurnBasedGame.sol\\\";\\nimport {LibQuadraticVoting} from \\\"../libraries/LibQuadraticVoting.sol\\\";\\n\\ninterface IRankifyInstanceCommons {\\n    struct RInstanceSettings {\\n        uint256 gamePrice;\\n        address gamePaymentToken;\\n        uint256 joinGamePrice;\\n        uint256 numGames;\\n        address rankTokenAddress;\\n        bool contractInitialized;\\n        LibQuadraticVoting.qVotingStruct voting;\\n    }\\n\\n    struct RInstanceState {\\n        RInstanceSettings BestOfState;\\n        LibTBG.GameSettings TBGSEttings;\\n    }\\n\\n    struct VoteHidden {\\n        bytes32 hash;\\n        bytes proof;\\n    }\\n\\n    struct RInstance {\\n        uint256 rank;\\n        address createdBy;\\n        mapping(uint256 => string) ongoingProposals; //Previous Turn Proposals (These are being voted on)\\n        uint256 numOngoingProposals;\\n        uint256 numPrevProposals;\\n        mapping(address => bytes32) proposalCommitmentHashes; //Current turn Proposal submittion\\n        uint256 numCommitments;\\n        mapping(address => VoteHidden) votesHidden;\\n        address[] additionalRanks;\\n        uint256 paymentsBalance;\\n        uint256 numVotesThisTurn;\\n        uint256 numVotesPrevTurn;\\n        mapping(address => bool) playerVoted;\\n    }\\n\\n    event RegistrationOpen(uint256 indexed gameid);\\n    event PlayerJoined(uint256 indexed gameId, address participant);\\n    event GameStarted(uint256 indexed gameId);\\n    event gameCreated(uint256 gameId, address indexed gm, address indexed creator, uint256 indexed rank);\\n    event GameClosed(uint256 indexed gameId);\\n    event PlayerLeft(uint256 indexed gameId, address indexed player);\\n}\\n\",\"keccak256\":\"0xca495b6a330a88cbfb1c3bfdac84fdd37242bba7fd10dd5582f8f664b6bdb19a\",\"license\":\"MIT\"},\"src/libraries/LibArray.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\nimport \\\"hardhat/console.sol\\\";\\n\\nlibrary LibArray {\\n    /**\\n     * @dev Sorts the elements of the array in ascending order using the quicksort algorithm.\\n     *\\n     * Requirements:\\n     *\\n     * - The array to be sorted must not be empty.\\n     * - The starting and ending indices must be within the bounds of the array.\\n     *\\n     * Modifies:\\n     *\\n     * - The array is sorted in ascending order.\\n     *\\n     * Note:\\n     *\\n     * - This function uses the in-place quicksort algorithm, which has an average-case complexity of O(n log n) and a worst-case complexity of O(n^2).\\n     */\\n    function quickSort(uint256[] memory arr, int256 left, int256 right) internal view {\\n        int256 i = left;\\n        int256 j = right;\\n        if (i == j) return;\\n        uint256 pivot = arr[uint256(left + (right - left) / 2)];\\n        while (i <= j) {\\n            while (arr[uint256(i)] > pivot) ++i;\\n            while (pivot > arr[uint256(j)]) j--;\\n            if (i <= j) {\\n                (arr[uint256(i)], arr[uint256(j)]) = (arr[uint256(j)], arr[uint256(i)]);\\n                ++i;\\n                j--;\\n            }\\n        }\\n        if (left < j) quickSort(arr, left, j);\\n        if (i < right) quickSort(arr, i, right);\\n    }\\n}\\n\",\"keccak256\":\"0x5afcd379801f32d7bc5e740b2b06a644454f1c347d65d8142d8543ff67197e95\",\"license\":\"MIT\"},\"src/libraries/LibCoinVending.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Author: Tim Pechersky <@Peersky>\\n\\npragma solidity ^0.8.20;\\n\\nimport {MockERC20} from \\\"../mocks/MockERC20.sol\\\";\\nimport {ERC1155Burnable} from \\\"@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Burnable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\\\";\\n\\n/**\\n * @dev This library is used to simulate the vending machine coin acceptor state machine that:\\n *  - Supports large number of positions; Each represents requirements to acess different goods of the virtual vending machine.\\n *  - Accepts multiple assets of following types: Native (Eth), ERC20, ERC721, and ERC1155 tokens that can be stacked together.\\n *  - Allows for each individual asset action promise can be one of following:\\n *      - Lock: The asset is locked in the acceptor with promise that asset will be returned to the sender at release funds time.\\n *      - Bet: The asset is locked in the acceptor with promise that asset will be awarded to benificiary at release funds time.\\n *      - Pay: The asset is locked in the acceptor with promise that asset will be paid to payee at release funds time.\\n *      - Burn: The asset is locked in the acceptor with promise that asset will be destroyed at release funds time.\\n *  - Maintains each position balance, hence allowing multiple participants to line up for the same position.\\n *  - Allows three actions:\\n *      - Fund position with assets\\n *      - Refund assets to user\\n *      - Consume assets and provide goods to user\\n *      - Consuming asset might take a form of\\n *      - Transferring assets to payee\\n *      - Burning assets\\n *      - Awarding beneficiary with assets\\n *      - Returning locked assets back to sender\\n *\\n * This library DOES enforces that any position can only be refunded or processed only within amount funded boundaries\\n * This library DOES NOT store the addresses of senders, nor benificiaries, nor payees.\\n * This is to be stored within implementation contract.\\n *\\n *\\n *  !!!!! IMPORTANT !!!!!\\n * This library does NOT invocates reentrancy guards. It is implementation contract's responsibility to enforce reentrancy guards.\\n * Reentrancy guards MUST be implemented in an implementing contract.\\n *\\n *  Usage:\\n *\\n *  0. Configure position via configure(...)\\n *  1. fund position with assets via fund(...)\\n *  2. release or refund assets via release(...) or refund(...)\\n *  3. repeat steps 1 and 2 as needed.\\n *  Position can be recofigured at any time when it's effective balance is zero: `timesFunded - timesRefuned - timesReleased = 0`\\n *\\n *\\n * Test state:\\n * This library most functionality has been tested: see ../tests/LibCoinVending.ts and ../tests/report.md for details.\\n *\\n * ERC721 token is checked only for \\\"HAVE\\\" condition since putting requirements on non fungable token id yet to be resolved.\\n * (see ERC721 section in the code below)\\n *\\n * This library has not been yet audited\\n *\\n */\\nlibrary LibCoinVending {\\n    struct Condition {\\n        mapping(ContractTypes => mapping(address => mapping(uint256 => ContractCondition))) contracts;\\n        NumericCondition ethValues;\\n        uint256 timesRefunded;\\n        uint256 timesReleased;\\n        uint256 timesFunded;\\n        ContractTypes[] contractTypes;\\n        address[] contractAddresses;\\n        uint256[] contractIds;\\n        bool _isConfigured;\\n    }\\n    enum RequirementTypes {\\n        HAVE,\\n        LOCK,\\n        BURN,\\n        BET,\\n        PAY\\n    }\\n\\n    struct TransactionProperties {\\n        bytes data;\\n        uint256 amount;\\n    }\\n    struct ContractCondition {\\n        TransactionProperties have;\\n        TransactionProperties lock;\\n        TransactionProperties burn;\\n        TransactionProperties pay;\\n        TransactionProperties bet;\\n    }\\n\\n    struct NumericCondition {\\n        uint256 have;\\n        uint256 lock;\\n        uint256 burn;\\n        uint256 pay;\\n        uint256 bet;\\n    }\\n\\n    enum TransferTypes {\\n        FUND,\\n        REFUND,\\n        RELEASE\\n    }\\n\\n    struct ConditionReturn {\\n        NumericCondition ethValues;\\n        uint256 timesRefunded;\\n        uint256 timesReleased;\\n        uint256 timesFunded;\\n        address[] contractAddresses;\\n        uint256[] contractIds;\\n        ContractTypes[] contractTypes;\\n        bool _isConfigured;\\n    }\\n\\n    struct configSmartRequirement {\\n        address contractAddress;\\n        uint256 contractId;\\n        ContractTypes contractType;\\n        ContractCondition contractRequirement;\\n    }\\n\\n    struct ConfigPosition {\\n        NumericCondition ethValues;\\n        configSmartRequirement[] contracts;\\n    }\\n\\n    struct LibCoinVendingStorage {\\n        mapping(bytes32 => Condition) positions;\\n        address beneficiary;\\n    }\\n\\n    enum ContractTypes {\\n        ERC20,\\n        ERC1155,\\n        ERC721\\n    }\\n\\n    bytes32 constant COIN_VENDING_STORAGE_POSITION = keccak256(\\\"coin.vending.storage.position\\\");\\n\\n    function coinVendingPosition(bytes32 position) internal view returns (Condition storage) {\\n        return coinVendingStorage().positions[keccak256(abi.encode(position))];\\n    }\\n\\n    function coinVendingStorage() internal pure returns (LibCoinVendingStorage storage es) {\\n        bytes32 position = COIN_VENDING_STORAGE_POSITION;\\n        assembly {\\n            es.slot := position\\n        }\\n    }\\n\\n    /**\\n     * @dev Transfers a specified amount of tokens from one address to another, or burns them if the destination address is zero.\\n     *\\n     * Requirements:\\n     *\\n     * - The `value` must be non-zero.\\n     * - The `from` address must have a sufficient token balance.\\n     * - If the `from` address is not this contract, it must have approved this contract to transfer tokens on its behalf.\\n     *\\n     * Modifies:\\n     *\\n     * - The token balances of the `from` and `to` addresses, or the total supply of tokens if `to` is the zero address.\\n     */\\n    function trasferFromAny(address erc20Addr, address from, address to, uint256 value) private {\\n        MockERC20 token = MockERC20(erc20Addr);\\n        if (value != 0) {\\n            if (from == address(this)) {\\n                if (to != address(0)) {\\n                    token.transfer(to, value);\\n                } else {\\n                    token.burn(value);\\n                }\\n            } else {\\n                if (to != address(0)) {\\n                    token.transferFrom(from, to, value);\\n                } else {\\n                    token.transferFrom(from, address(this), value);\\n                    token.burn(value);\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Fulfills the ERC20 token transfer according to the specified rules.\\n     *\\n     * Requirements:\\n     *\\n     * - The `from` address must have a sufficient token balance.\\n     * - If the `from` address is not this contract, it must have approved this contract to transfer tokens on its behalf.\\n     *\\n     * Modifies:\\n     *\\n     * - The token balances of the `from` and `to` addresses.\\n     */\\n    function fulfillERC20(\\n        address erc20Addr,\\n        ContractCondition storage tokenReq,\\n        address from,\\n        address payee,\\n        address beneficiary,\\n        address burnAddress,\\n        address lockAddress\\n    ) private {\\n        trasferFromAny(erc20Addr, from, lockAddress, tokenReq.lock.amount);\\n        trasferFromAny(erc20Addr, from, burnAddress, tokenReq.burn.amount);\\n        trasferFromAny(erc20Addr, from, payee, tokenReq.pay.amount);\\n        trasferFromAny(erc20Addr, from, beneficiary, tokenReq.bet.amount);\\n        MockERC20 token = MockERC20(erc20Addr);\\n        uint256 value = tokenReq.have.amount;\\n        if (value != 0 && from != address(this)) {\\n            require(token.balanceOf(from) >= value, \\\"Not enough erc20 tokens\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Fulfills the ERC721 token transfer according to the specified rules.\\n     *\\n     * Requirements:\\n     *\\n     * - The `from` address must own the token.\\n     * - If the `from` address is not this contract, it must have approved this contract to transfer the token on its behalf.\\n     *\\n     * Modifies:\\n     *\\n     * - The token ownership from the `from` address to the `to` address.\\n     *\\n     * Notes:\\n     *\\n     * Due to non fungable nature it's an open question how to implement this method correctly for lock/burn/pay/bet cases.\\n     * In this library I assume that requirements are for multiple members, hence it makes no sense to put requirement on particular tokenId for ERC721.\\n     * I think best approach would be to split in to two methods:\\n     *  1. fulfillERC72Balance: Treats tokens as fungible - requires one to lock/burn/pay/bet ANY token id, but in total should be equal to desired value.\\n     *  2. fulfillERC721Ids: Requires one to lock/burn/pay/bet specific token id. (useful when requirements are unique per applicant).\\n     * fulfillERC72Balance is easy. fulfillERC721Ids brings up a question of how to select those ID's(since must specify for ERC721 contract on transfer method).\\n     *  Two possible solutions:\\n     *  1: modify fund() method to accept array of address+id pairs of NFT's and parse trough it. Compucationaly inefficient.\\n     *  2: implement onERC721Received such that there is NFT vault in the contract, later fill funding position from that vault. That way applicant could pre-send NFT's to the contract and callfing fund later would pull those out from the vault.\\n\\n     */\\n    function fulfillERC72Balance(address erc721addr, ContractCondition storage tokenReq, address from) private view {\\n        ERC721 token = ERC721(erc721addr);\\n\\n        require(\\n            tokenReq.lock.amount == 0 &&\\n                tokenReq.burn.amount == 0 &&\\n                tokenReq.pay.amount == 0 &&\\n                tokenReq.bet.amount == 0,\\n            \\\"ERC721 transfers not supported\\\"\\n        );\\n        if (tokenReq.have.amount != 0 && from != address(this)) {\\n            uint256 balance = token.balanceOf(from);\\n            require(balance >= tokenReq.have.amount, \\\"Not enough ERC721 balance\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Fulfills the ERC1155 token transfer according to the specified rules.\\n     *\\n     * Requirements:\\n     *\\n     * - The `from` address must own the token.\\n     * - If the `from` address is not this contract, it must have approved this contract to transfer the token on its behalf.\\n     *\\n     * Modifies:\\n     *\\n     * - The token ownership from the `from` address to the `to` address.\\n     */\\n    function fulfillERC1155(\\n        address erc1155addr,\\n        uint256 id,\\n        ContractCondition storage tokenReq,\\n        address from,\\n        address payee,\\n        address beneficiary,\\n        address burnAddress,\\n        address lockAddress\\n    ) private {\\n        ERC1155Burnable token = ERC1155Burnable(erc1155addr);\\n        uint256 value = tokenReq.have.amount;\\n        if (value != 0) {\\n            uint256 balance = token.balanceOf(from, id);\\n            require(balance >= value, \\\"ERC1155 balance is not valid\\\");\\n        }\\n        value = tokenReq.pay.amount;\\n        if (value != 0) {\\n            // token.transfe\\n            token.safeTransferFrom(from, payee, id, value, tokenReq.pay.data);\\n        }\\n        value = tokenReq.bet.amount;\\n        if (value != 0) {\\n            token.safeTransferFrom(from, beneficiary, id, value, tokenReq.bet.data);\\n        }\\n        value = tokenReq.burn.amount;\\n        if (value != 0) {\\n            if (burnAddress == address(0)) {\\n                token.burn(from, id, value);\\n            } else {\\n                token.safeTransferFrom(from, burnAddress, id, value, tokenReq.burn.data);\\n            }\\n        }\\n        value = tokenReq.lock.amount;\\n        if (value != 0) {\\n            token.safeTransferFrom(from, lockAddress, id, value, tokenReq.lock.data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Fulfills the conditions of a position.\\n     *\\n     * Requirements:\\n     *\\n     * - If `from` is not this contract, the sent value must be greater than or equal to the sum of the locked, paid, bet, and burned values.\\n     *\\n     * Modifies:\\n     *\\n     * - Transfers the specified amounts of Ether to the lock, payee, beneficiary, and burn addresses.\\n     */\\n    function fulfill(\\n        Condition storage position,\\n        address from,\\n        address payee,\\n        address beneficiary,\\n        address burnAddress,\\n        address lockAddress\\n    ) private {\\n        if (from == address(this)) {\\n            if (position.ethValues.lock != 0) {\\n                payable(lockAddress).transfer(position.ethValues.lock);\\n            }\\n            if (position.ethValues.pay != 0) {\\n                payable(payee).transfer(position.ethValues.pay);\\n            }\\n            if (position.ethValues.bet != 0) {\\n                payable(beneficiary).transfer(position.ethValues.bet);\\n            }\\n            if (position.ethValues.burn != 0) {\\n                payable(burnAddress).transfer(position.ethValues.burn);\\n            }\\n        } else {\\n            uint256 VLReq = position.ethValues.lock +\\n                position.ethValues.pay +\\n                position.ethValues.bet +\\n                position.ethValues.burn;\\n            require(msg.value >= VLReq, \\\"msg.value too low\\\");\\n        }\\n        for (uint256 i = 0; i < position.contractAddresses.length; ++i) {\\n            address contractAddress = position.contractAddresses[i];\\n            uint256 id = position.contractIds[i];\\n            ContractTypes contractType = position.contractTypes[i];\\n            ContractCondition storage requirement = position.contracts[contractType][contractAddress][id];\\n            if (contractType == ContractTypes.ERC20) {\\n                fulfillERC20(contractAddress, requirement, from, payee, beneficiary, burnAddress, lockAddress);\\n            } else if (contractType == ContractTypes.ERC721) {\\n                fulfillERC72Balance(\\n                    contractAddress,\\n                    // id,\\n                    requirement,\\n                    from\\n                    // payee,\\n                    // beneficiary,\\n                    // burnAddress,\\n                    // lockAddress\\n                );\\n            } else if (contractType == ContractTypes.ERC1155) {\\n                fulfillERC1155(contractAddress, id, requirement, from, payee, beneficiary, burnAddress, lockAddress);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Refunds the balance of a condition to the specified address.\\n     *\\n     * `reqPos` The storage reference to the condition.\\n     * `to` The address to refund the balance to.\\n     *\\n     * Requirements:\\n     *\\n     * - The sum of `timesRefunded` and `timesReleased` for the condition must be less than `timesFunded`.\\n     *\\n     * Modifies:\\n     *\\n     * - Transfers the remaining balance of the condition to the `to` address.\\n     * - Increments the `timesRefunded` counter for the condition.\\n     */\\n    function _refund(Condition storage reqPos, address to) private {\\n        require((reqPos.timesRefunded + reqPos.timesReleased) < reqPos.timesFunded, \\\"Not enough balance to refund\\\");\\n        fulfill(reqPos, address(this), to, to, to, to);\\n        reqPos.timesRefunded += 1;\\n    }\\n\\n    /**\\n     * @dev Returns all position requirements back to fundee. `position` is the identifier of the condition. `to` is the address to refund the balance to.\\n     *\\n     * Requirements:\\n     *\\n     * - The sum of `timesRefunded` and `timesReleased` for the condition must be less than `timesFunded`.\\n     *\\n     * Modifies:\\n     *\\n     * - Transfers the remaining balance of the condition to the `to` address.\\n     * - Increments the `timesRefunded` counter for the condition.\\n     */\\n    function refund(bytes32 position, address to) internal {\\n        Condition storage reqPos = coinVendingPosition(position);\\n        _refund(reqPos, to);\\n    }\\n\\n    /**\\n     * @dev Returns all position requirements back to multiple fundees. `position` is the identifier of the condition. `returnAddresses` is an array of addresses to refund the balance to.\\n     *\\n     * Requirements:\\n     *\\n     * - The sum of `timesRefunded` and `timesReleased` for the condition must be less than `timesFunded`.\\n     *\\n     * Modifies:\\n     *\\n     * - Transfers the remaining balance of the condition to each address in `returnAddresses`.\\n     * - Increments the `timesRefunded` counter for the condition for each address in `returnAddresses`.\\n     */\\n    function batchRefund(bytes32 position, address[] memory returnAddresses) internal {\\n        Condition storage reqPos = coinVendingPosition(position);\\n        for (uint256 i = 0; i < returnAddresses.length; ++i) {\\n            _refund(reqPos, returnAddresses[i]);\\n        }\\n    }\\n\\n    function _release(Condition storage reqPos, address payee, address beneficiary, address returnAddress) private {\\n        require((reqPos.timesRefunded + reqPos.timesReleased) < reqPos.timesFunded, \\\"Not enough balance to release\\\");\\n        fulfill(reqPos, address(this), payee, beneficiary, address(0), returnAddress);\\n        reqPos.timesReleased += 1;\\n    }\\n\\n    /**\\n     * @dev Releases the funds from a coin vending position to the specified addresses. `position` is the identifier of the condition. `payee`, `beneficiary`, and `returnAddress` are the addresses to release the funds to.\\n     *\\n     * Requirements:\\n     *\\n     * - The sum of `timesRefunded` and `timesReleased` for the condition must be less than `timesFunded`.\\n     *\\n     * Modifies:\\n     *\\n     * - Transfers the remaining balance of the condition to the `payee`, `beneficiary`, and `returnAddress`.\\n     * - Increments the `timesReleased` counter for the condition.\\n     */\\n    function release(bytes32 position, address payee, address beneficiary, address returnAddress) internal {\\n        Condition storage reqPos = coinVendingPosition(position);\\n        _release(reqPos, payee, beneficiary, returnAddress);\\n    }\\n\\n    /**\\n     * @dev Releases the funds from a coin vending position to multiple return addresses. `position` is the identifier of the condition. `payee`, `beneficiary`, and `returnAddresses` are the addresses to release the funds to.\\n     *\\n     * Requirements:\\n     *\\n     * - The sum of `timesRefunded` and `timesReleased` for the condition must be less than `timesFunded`.\\n     *\\n     * Modifies:\\n     *\\n     * - Transfers the remaining balance of the condition to the `payee`, `beneficiary`, and each address in `returnAddresses`.\\n     * - Increments the `timesReleased` counter for the condition for each address in `returnAddresses`.\\n     */\\n    function batchRelease(\\n        bytes32 position,\\n        address payee,\\n        address beneficiary,\\n        address[] memory returnAddresses\\n    ) internal {\\n        Condition storage reqPos = coinVendingPosition(position);\\n        for (uint256 i = 0; i < returnAddresses.length; ++i) {\\n            {\\n                _release(reqPos, payee, beneficiary, returnAddresses[i]);\\n            }\\n        }\\n    }\\n\\n    function _fund(Condition storage reqPos, address funder) private {\\n        require(reqPos._isConfigured, \\\"Position does not exist\\\");\\n        fulfill(reqPos, funder, address(this), address(this), address(this), address(this));\\n        reqPos.timesFunded += 1;\\n    }\\n\\n    /**\\n     * @dev Funds the position by `msg.sender`. `position` is the identifier of the condition.\\n     *\\n     * Requirements:\\n     *\\n     * - The condition must be configured.\\n     *\\n     * Modifies:\\n     *\\n     * - Transfers the funds from `msg.sender` to this contract.\\n     * - Increments the `timesFunded` counter for the condition.\\n     */\\n    function fund(bytes32 position) internal {\\n        Condition storage reqPos = coinVendingPosition(position);\\n        _fund(reqPos, msg.sender);\\n    }\\n\\n    /**\\n     * @dev Configures the position. `position` is the identifier of the condition. `configuration` is the new configuration for the condition.\\n     *\\n     * Requirements:\\n     *\\n     * - The condition must not have a positive balance.\\n     *\\n     * Modifies:\\n     *\\n     * - Sets the configuration of the condition to `configuration`.\\n     */\\n    function configure(bytes32 position, ConfigPosition memory configuration) internal {\\n        Condition storage mustDo = coinVendingPosition(position);\\n        require(\\n            mustDo.timesFunded == 0 || (mustDo.timesFunded == (mustDo.timesRefunded + mustDo.timesReleased)),\\n            \\\"Cannot mutate position with currently positive balance\\\"\\n        );\\n        mustDo.ethValues = configuration.ethValues;\\n        delete mustDo.contractAddresses;\\n        delete mustDo.contractIds;\\n        delete mustDo.contractTypes;\\n        for (uint256 i = 0; i < configuration.contracts.length; ++i) {\\n            mustDo.contractAddresses.push(configuration.contracts[i].contractAddress);\\n            mustDo.contractIds.push(configuration.contracts[i].contractId);\\n            mustDo.contractTypes.push(configuration.contracts[i].contractType);\\n            mustDo.contracts[configuration.contracts[i].contractType][configuration.contracts[i].contractAddress][\\n                configuration.contracts[i].contractId\\n            ] = configuration.contracts[i].contractRequirement;\\n        }\\n        mustDo._isConfigured = true;\\n    }\\n\\n    /**\\n     * @dev Returns the condition associated with the given position. `position` is the identifier of the condition.\\n     *\\n     * Returns:\\n     *\\n     * - The condition associated with `position`.\\n     */\\n    function getPosition(bytes32 position) internal view returns (ConditionReturn memory) {\\n        Condition storage pos = coinVendingPosition(position);\\n        ConditionReturn memory ret;\\n        ret.ethValues = pos.ethValues;\\n        ret.timesFunded = pos.timesFunded;\\n        ret.timesRefunded = pos.timesRefunded;\\n        ret.timesReleased = pos.timesReleased;\\n        ret._isConfigured = pos._isConfigured;\\n        ret.contractAddresses = pos.contractAddresses;\\n        ret.contractIds = pos.contractIds;\\n        ret.contractTypes = pos.contractTypes;\\n        return ret;\\n    }\\n\\n    /**\\n     * @dev Returns the contract condition associated with the given position, contract address, contract ID, and contract type. `position` is the identifier of the condition. `contractAddress` is the address of the contract. `contractId` is the ID of the contract. `contractType` is the type of the contract.\\n     *\\n     * Returns:\\n     *\\n     * - The contract condition associated with `position`, `contractAddress`, `contractId`, and `contractType`.\\n     */\\n    function getPositionByContract(\\n        bytes32 position,\\n        address contractAddress,\\n        uint256 contractId,\\n        ContractTypes contractType\\n    ) internal view returns (ContractCondition memory) {\\n        Condition storage pos = coinVendingPosition(position);\\n        return pos.contracts[contractType][contractAddress][contractId];\\n    }\\n}\\n\",\"keccak256\":\"0xb3c762575bdfaaff7c9a57b153f039bad82412c6cd9a81a379c6b938b7126c22\",\"license\":\"MIT\"},\"src/libraries/LibEIP712Storage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport {IDiamondCut} from \\\"../vendor/diamond/interfaces/IDiamondCut.sol\\\";\\n\\nlibrary LibEIP712WithStorage {\\n    bytes32 constant EIP712_STORAGE_POSITION = keccak256(\\\"EIP.712.STORAGE.POSITION\\\");\\n\\n    struct LibEIP712WithStorageStorage {\\n        bytes32 _CACHED_DOMAIN_SEPARATOR;\\n        uint256 _CACHED_CHAIN_ID;\\n        address _CACHED_THIS;\\n        bytes32 _HASHED_NAME;\\n        bytes32 _HASHED_VERSION;\\n        bytes32 _TYPE_HASH;\\n    }\\n\\n    function EIP712WithStorage() internal pure returns (LibEIP712WithStorageStorage storage ds) {\\n        bytes32 position = EIP712_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x08583ddcb7616e208aa39f88777b1ce1661ff60b2e446678372ac7e152ad5c2f\",\"license\":\"MIT\"},\"src/libraries/LibQuadraticVoting.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {Math} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nerror quadraticVotingError(string paramter, uint256 arg, uint256 arg2);\\n\\n/**\\n * @title LibQuadraticVoting\\n * @dev A library for quadratic voting calculations.\\n */\\nlibrary LibQuadraticVoting {\\n    struct qVotingStruct {\\n        uint256 voteCredits;\\n        uint256 maxQuadraticPoints;\\n        uint256 minQuadraticPositons;\\n    }\\n\\n    /**\\n     * @dev Precomputes the values for quadratic voting. `voteCredits` is the total number of vote credits. `minExpectedVoteItems` is the minimum expected number of vote items.\\n     *\\n     * Returns:\\n     *\\n     * - A `qVotingStruct` containing the precomputed values.\\n     */\\n    function precomputeValues(\\n        uint256 voteCredits,\\n        uint256 minExpectedVoteItems\\n    ) internal pure returns (qVotingStruct memory) {\\n        qVotingStruct memory q;\\n\\n        q.maxQuadraticPoints = Math.sqrt(voteCredits);\\n\\n        // This block finds how many vote positions are needed to distribute all quadratic vote points.\\n        uint256 iterator = 0;\\n        uint256 accumulator = 0;\\n        do {\\n            accumulator += (q.maxQuadraticPoints - iterator) ** 2;\\n            iterator++;\\n        } while (accumulator < voteCredits);\\n        // This enforces requirement that all vote credits can indeed be spended (no leftovers)\\n        if (accumulator != voteCredits) require(false, \\\"quadraticVotingError: voteCredits bust be i^2 series\\\"); //revert quadraticVotingError(\\\"voteCredits bust be i^2 series\\\", accumulator, voteCredits);\\n        q.minQuadraticPositons = iterator;\\n        // In order to spend all vote credits there must be at least minQuadraticPositons+1 (becuase proposer is also a player and cannot vote for himself)\\n        if (minExpectedVoteItems <= q.minQuadraticPositons)\\n            require(false, \\\"quadraticVotingError: Minimum Voting positions above min players\\\");\\n        // revert quadraticVotingError(\\n        //     \\\"Minimum Voting positions above min players\\\",\\n        //     q.minQuadraticPositons,\\n        //     minExpectedVoteItems\\n        // );\\n        q.voteCredits = voteCredits;\\n        return q;\\n    }\\n\\n    /**\\n     * @dev Computes the scores for each proposal by voter preference index. `q` is the precomputed quadratic voting values. `VotersVotes` is a 2D array of votes, where each row corresponds to a voter and each column corresponds to a proposal. `voterVoted` is an array indicating whether each voter has voted. `notVotedGivesEveyone` is the number of points to distribute to each proposal for each voter that did not vote. `proposalsLength` is the number of proposals.\\n     *\\n     * Returns:\\n     *\\n     * - An array of scores for each proposal.\\n     */\\n    function computeScoresByVPIndex(\\n        qVotingStruct memory q,\\n        uint256[][] memory VotersVotes,\\n        bool[] memory voterVoted,\\n        uint256 notVotedGivesEveyone,\\n        uint256 proposalsLength\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory scores = new uint256[](proposalsLength);\\n        uint256[] memory creditsUsed = new uint256[](VotersVotes.length);\\n\\n        for (uint256 proposalIdx = 0; proposalIdx < proposalsLength; proposalIdx++) {\\n            //For each proposal\\n            scores[proposalIdx] = 0;\\n            for (uint256 vi = 0; vi < VotersVotes.length; vi++) {\\n                // For each potential voter\\n                uint256[] memory voterVotes = VotersVotes[vi];\\n                if (!voterVoted[vi]) {\\n                    // Check if voter wasn't voting\\n                    scores[proposalIdx] += notVotedGivesEveyone; // Gives benefits to everyone but himself\\n                    creditsUsed[vi] = q.voteCredits;\\n                } else {\\n                    //If voter voted\\n                    scores[proposalIdx] += voterVotes[proposalIdx];\\n                    creditsUsed[vi] += voterVotes[proposalIdx] ** 2;\\n                    if (creditsUsed[vi] > q.voteCredits) require(false, \\\"quadraticVotingError\\\"); // revert quadraticVotingError(\\\"Quadratic: vote credits overrun\\\", q.voteCredits, creditsUsed[vi]);\\n                }\\n            }\\n        }\\n        return scores;\\n    }\\n}\\n\",\"keccak256\":\"0xcf8d392a2f768c9c5d5af7b641bf0d9b5273ac8f3ba4e41c568576c78085e44a\",\"license\":\"MIT\"},\"src/libraries/LibRankify.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\nimport {LibTBG} from \\\"../libraries/LibTurnBasedGame.sol\\\";\\nimport {IRankifyInstanceCommons} from \\\"../interfaces/IRankifyInstanceCommons.sol\\\";\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport {IRankToken} from \\\"../interfaces/IRankToken.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/interfaces/IERC20.sol\\\";\\nimport {LibQuadraticVoting} from \\\"./LibQuadraticVoting.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\nlibrary LibRankify {\\n    using LibTBG for LibTBG.GameInstance;\\n    using LibTBG for uint256;\\n    using LibTBG for LibTBG.GameSettings;\\n    using LibQuadraticVoting for LibQuadraticVoting.qVotingStruct;\\n\\n    /**\\n     * @dev Compares two strings for equality. `a` and `b` are the strings to compare.\\n     *\\n     * Returns:\\n     *\\n     * - `true` if the strings are equal, `false` otherwise.\\n     */\\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\\n    }\\n\\n    /**\\n     * @dev Returns the game storage for the given game ID. `gameId` is the ID of the game.\\n     *\\n     * Returns:\\n     *\\n     * - The game storage for `gameId`.\\n     */\\n    function getGameStorage(uint256 gameId) internal view returns (IRankifyInstanceCommons.RInstance storage game) {\\n        bytes32 position = LibTBG.getGameDataStorage(gameId);\\n        assembly {\\n            game.slot := position\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the Rankify InstanceSettings storage.\\n     *\\n     * Returns:\\n     *\\n     * - The RInstanceSettings storage.\\n     */\\n    function RInstanceStorage() internal pure returns (IRankifyInstanceCommons.RInstanceSettings storage bog) {\\n        bytes32 position = LibTBG.getDataStorage();\\n        assembly {\\n            bog.slot := position\\n        }\\n    }\\n\\n    bytes32 internal constant _PROPOSAL_PROOF_TYPEHASH =\\n        keccak256(\\\"signProposalByGM(uint256 gameId,uint256 turn,bytes32 proposalNHash,string encryptedProposal)\\\");\\n    bytes32 internal constant _VOTE_PROOF_TYPEHASH =\\n        keccak256(\\\"signVote(uint256 vote1,uint256 vote2,uint256 vote3,uint256 gameId,uint256 turn,bytes32 salt)\\\");\\n    bytes32 internal constant _VOTE_SUBMIT_PROOF_TYPEHASH =\\n        keccak256(\\\"publicSignVote(uint256 gameId,uint256 turn,bytes32 vote1,bytes32 vote2,bytes32 vote3)\\\");\\n\\n    /**\\n     * @dev Ensures that the contract is initialized.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be initialized.\\n     */\\n    function enforceIsInitialized() internal view {\\n        IRankifyInstanceCommons.RInstanceSettings storage settings = RInstanceStorage();\\n        require(settings.contractInitialized, \\\"onlyInitialized\\\");\\n    }\\n\\n    /**\\n     * @dev Ensures that the game with the given ID exists. `gameId` is the ID of the game.\\n     *\\n     * Requirements:\\n     *\\n     * - The game with `gameId` must exist.\\n     */\\n    function enforceGameExists(uint256 gameId) internal view {\\n        enforceIsInitialized();\\n        require(gameId.gameExists(), \\\"no game found\\\");\\n    }\\n\\n    /**\\n     * @dev Creates a new game with the given parameters. `gameId` is the ID of the new game. `gameMaster` is the address of the game master. `gameRank` is the rank of the game. `creator` is the address of the creator of the game.\\n     *\\n     * Requirements:\\n     *\\n     * - The game with `gameId` must not already exist.\\n     * - `gameRank` must not be 0.\\n     * - If the game price is not 0, the `creator` must have approved this contract to transfer the game price amount of the game payment token on their behalf.\\n     *\\n     * Modifies:\\n     *\\n     * - Creates a new game with `gameId`.\\n     * - Transfers the game price amount of the game payment token from `creator` to this contract.\\n     * - Sets the payments balance of the game to the game price.\\n     * - Sets the creator of the game to `creator`.\\n     * - Increments the number of games.\\n     * - Sets the rank of the game to `gameRank`.\\n     * - Mints new rank tokens.\\n     */\\n    function newGame(uint256 gameId, address gameMaster, uint256 gameRank, address creator) internal {\\n        LibRankify.enforceIsInitialized();\\n        IRankifyInstanceCommons.RInstanceSettings storage settings = RInstanceStorage();\\n        gameId.createGame(gameMaster); // This will enforce game does not exist yet\\n        IRankifyInstanceCommons.RInstance storage game = getGameStorage(gameId);\\n        require(gameRank != 0, \\\"game rank not specified\\\");\\n        if (settings.gamePrice != 0) {\\n            IERC20(settings.gamePaymentToken).transferFrom(creator, address(this), settings.gamePrice);\\n            game.paymentsBalance = settings.gamePrice;\\n        }\\n\\n        game.createdBy = creator;\\n        settings.numGames += 1;\\n        game.rank = gameRank;\\n\\n        IRankToken rankTokenContract = IRankToken(settings.rankTokenAddress);\\n        rankTokenContract.mint(address(this), 1, gameRank + 1, \\\"\\\");\\n        rankTokenContract.mint(address(this), 3, gameRank, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Ensures that the candidate is the creator of the game with the given ID. `gameId` is the ID of the game. `candidate` is the address of the candidate.\\n     *\\n     * Requirements:\\n     *\\n     * - The game with `gameId` must exist.\\n     * - `candidate` must be the creator of the game.\\n     */\\n    function enforceIsGameCreator(uint256 gameId, address candidate) internal view {\\n        enforceGameExists(gameId);\\n        IRankifyInstanceCommons.RInstance storage game = getGameStorage(gameId);\\n        require(game.createdBy == candidate, \\\"Only game creator\\\");\\n    }\\n\\n    /**\\n     * @dev Ensures that the candidate is the game master of the game with the given ID. `gameId` is the ID of the game. `candidate` is the address of the candidate.\\n     *\\n     * Requirements:\\n     *\\n     * - The game with `gameId` must exist.\\n     * - `candidate` must be the game master of the game.\\n     */\\n    function enforceIsGM(uint256 gameId, address candidate) internal view {\\n        enforceGameExists(gameId);\\n        require(gameId.getGM() == candidate, \\\"Only game master\\\");\\n    }\\n\\n    /**\\n     * @dev Locks the rank token of the player. `player` is the address of the player. `gameRank` is the rank of the game. `rankTokenAddress` is the address of the rank token contract.\\n     *\\n     * Requirements:\\n     *\\n     * - `RankTokenAddress` must support `IRankToken` interface\\n     *\\n     * Modifies:\\n     *\\n     * - Locks `gameRank` rank of `player` in the rank token contract.\\n     */\\n    function _fulfillRankRq(address player, uint256 gameRank, address rankTokenAddress) private {\\n        IRankToken rankToken = IRankToken(rankTokenAddress);\\n        rankToken.lock(player, gameRank, 1);\\n    }\\n\\n    /**\\n     * @dev Allows a player to join a game. `gameId` is the ID of the game. `player` is the address of the player.\\n     *\\n     * Requirements:\\n     *\\n     * - The game with `gameId` must exist.\\n     * - If the join game price is not 0, the `player` must have approved this contract to transfer the join game price amount of the game payment token on their behalf.\\n     *\\n     * Modifies:\\n     *\\n     * - Transfers the join game price amount of the game payment token from `player` to this contract.\\n     * - Increases the payments balance of the game by the join game price.\\n     * - Adds `player` to the game.\\n     */\\n    function joinGame(uint256 gameId, address player) internal {\\n        enforceGameExists(gameId);\\n        fulfillRankRq(gameId, player);\\n        IRankifyInstanceCommons.RInstanceSettings storage _RInstance = RInstanceStorage();\\n        if (_RInstance.joinGamePrice != 0) {\\n            IERC20(_RInstance.gamePaymentToken).transferFrom(player, address(this), _RInstance.joinGamePrice);\\n            IRankifyInstanceCommons.RInstance storage game = getGameStorage(gameId);\\n            game.paymentsBalance += _RInstance.joinGamePrice;\\n        }\\n        gameId.addPlayer(player);\\n    }\\n\\n    /**\\n     * @dev Closes the game with the given ID and transfers the game's balance to the beneficiary. `gameId` is the ID of the game. `beneficiary` is the address to transfer the game's balance to. `playersGameEndedCallback` is a callback function to call for each player when the game ends.\\n     *\\n     * Requirements:\\n     *\\n     * - The game with `gameId` must exist.\\n     *\\n     * Modifies:\\n     *\\n     * - Emits rank rewards for the game.\\n     * - Removes and unlocks each player from the game.\\n     * - Calls `playersGameEndedCallback` for each player.\\n     * - Transfers the game's balance to `beneficiary`.\\n     *\\n     * Returns:\\n     *\\n     * - The final scores of the game.\\n     */\\n    function closeGame(\\n        uint256 gameId,\\n        address beneficiary,\\n        function(uint256, address) playersGameEndedCallback\\n    ) internal returns (uint256[] memory) {\\n        enforceGameExists(gameId);\\n        emitRankRewards(gameId, gameId.getLeaderBoard());\\n        (, uint256[] memory finalScores) = gameId.getScores();\\n        address[] memory players = gameId.getPlayers();\\n        for (uint256 i = 0; i < players.length; ++i) {\\n            removeAndUnlockPlayer(gameId, players[i]);\\n            playersGameEndedCallback(gameId, players[i]);\\n        }\\n        IRankifyInstanceCommons.RInstanceSettings storage _RInstance = LibRankify.RInstanceStorage();\\n        IERC20(_RInstance.gamePaymentToken).transfer(\\n            beneficiary,\\n            (_RInstance.joinGamePrice * players.length) + _RInstance.gamePrice\\n        );\\n        return finalScores;\\n    }\\n\\n    /**\\n     * @dev Allows a player to quit a game. `gameId` is the ID of the game. `player` is the address of the player. `slash` is a boolean indicating whether to slash the player's payment refund. `onPlayerLeftCallback` is a callback function to call when the player leaves.\\n     *\\n     * Requirements:\\n     *\\n     * - The game with `gameId` must exist.\\n     *\\n     * Modifies:\\n     *\\n     * - If the join game price is not 0, transfers a refund to `player` and decreases the game's payments balance by the refund amount.\\n     * - Removes and unlocks `player` from the game.\\n     * - Calls `onPlayerLeftCallback` for `player`.\\n     */\\n    function quitGame(\\n        uint256 gameId,\\n        address player,\\n        bool slash,\\n        function(uint256, address) onPlayerLeftCallback\\n    ) internal {\\n        IRankifyInstanceCommons.RInstanceSettings storage _RInstance = RInstanceStorage();\\n        if (_RInstance.joinGamePrice != 0) {\\n            uint256 divideBy = slash ? 2 : 1;\\n            uint256 paymentRefund = _RInstance.joinGamePrice / divideBy;\\n            IRankifyInstanceCommons.RInstance storage game = getGameStorage(gameId);\\n            game.paymentsBalance -= paymentRefund;\\n            IERC20(_RInstance.gamePaymentToken).transfer(player, paymentRefund);\\n        }\\n        removeAndUnlockPlayer(gameId, player); // this will throw if game has started or doesnt exist\\n        onPlayerLeftCallback(gameId, player);\\n    }\\n\\n    /**\\n     * @dev Cancels the game with the given ID, refunds half of the game's payment to the game creator, and transfers the remaining balance to the beneficiary. `gameId` is the ID of the game. `onPlayerLeftCallback` is a callback function to call for each player when they leave. `beneficiary` is the address to transfer the remaining balance to.\\n     *\\n     * Requirements:\\n     *\\n     * - The game with `gameId` must exist.\\n     *\\n     * Modifies:\\n     *\\n     * - Calls `quitGame` for each player in the game.\\n     * - Transfers half of the game's payment to the game creator.\\n     * - Decreases the game's payments balance by the refund amount.\\n     * - Transfers the remaining balance of the game to `beneficiary`.\\n     * - Deletes the game.\\n     */ function cancelGame(\\n        uint256 gameId,\\n        function(uint256, address) onPlayerLeftCallback,\\n        address beneficiary\\n    ) internal {\\n        // Cancel the game for each player\\n        address[] memory players = gameId.getPlayers();\\n        for (uint256 i = 0; i < players.length; ++i) {\\n            quitGame(gameId, players[i], false, onPlayerLeftCallback); //this will throw if game has started or doesnt exist\\n        }\\n\\n        // Refund payment to the game creator\\n        IRankifyInstanceCommons.RInstance storage game = getGameStorage(gameId);\\n        IRankifyInstanceCommons.RInstanceSettings storage _RInstance = RInstanceStorage();\\n        uint256 paymentRefund = _RInstance.gamePrice / 2;\\n        IERC20(_RInstance.gamePaymentToken).transfer(game.createdBy, paymentRefund);\\n        game.paymentsBalance -= paymentRefund;\\n\\n        // Transfer remaining payments balance to the beneficiary\\n        IERC20(_RInstance.gamePaymentToken).transfer(beneficiary, game.paymentsBalance);\\n        game.paymentsBalance = 0;\\n\\n        // Delete the game\\n        gameId.deleteGame();\\n    }\\n\\n    /**\\n     * @dev Fulfills the rank requirement for a player to join a game. `gameId` is the ID of the game. `player` is the address of the player.\\n     *\\n     * Modifies:\\n     *\\n     * - Locks the rank token(s) of `player` in the rank token contract.\\n     * - If the game has additional ranks, locks the additional ranks of `player` in the respective rank token contracts.\\n     */\\n    function fulfillRankRq(uint256 gameId, address player) internal {\\n        IRankifyInstanceCommons.RInstanceSettings storage settings = RInstanceStorage();\\n        IRankifyInstanceCommons.RInstance storage game = getGameStorage(gameId);\\n        if (game.rank > 1) {\\n            _fulfillRankRq(player, game.rank, settings.rankTokenAddress);\\n            for (uint256 i = 0; i < game.additionalRanks.length; ++i) {\\n                _fulfillRankRq(player, game.rank, game.additionalRanks[i]);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Emits rank rewards to the top three addresses in the leaderboard. `gameId` is the ID of the game. `leaderboard` is an array of addresses representing the leaderboard sorted in descendign order. `rankTokenAddress` is the address of the rank token contract.\\n     *\\n     * Modifies:\\n     *\\n     * - Transfers rank tokens from this contract to the top three addresses in the leaderboard.\\n     */\\n    function emitRankReward(uint256 gameId, address[] memory leaderboard, address rankTokenAddress) private {\\n        IRankifyInstanceCommons.RInstance storage game = getGameStorage(gameId);\\n        IRankToken rankTokenContract = IRankToken(rankTokenAddress);\\n        rankTokenContract.safeTransferFrom(address(this), leaderboard[0], game.rank + 1, 1, \\\"\\\");\\n        rankTokenContract.safeTransferFrom(address(this), leaderboard[1], game.rank, 2, \\\"\\\");\\n        rankTokenContract.safeTransferFrom(address(this), leaderboard[2], game.rank, 1, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Emits rank rewards to the top addresses in the leaderboard for each rank in the game. `gameId` is the ID of the game. `leaderboard` is an array of addresses representing the leaderboard.\\n     *\\n     * Modifies:\\n     *\\n     * - Calls `emitRankReward` for the main rank and each additional rank in the game.\\n     */\\n    function emitRankRewards(uint256 gameId, address[] memory leaderboard) internal {\\n        IRankifyInstanceCommons.RInstance storage game = getGameStorage(gameId);\\n        IRankifyInstanceCommons.RInstanceSettings storage settings = LibRankify.RInstanceStorage();\\n        emitRankReward(gameId, leaderboard, settings.rankTokenAddress);\\n        for (uint256 i = 0; i < game.additionalRanks.length; ++i) {\\n            emitRankReward(gameId, leaderboard, game.additionalRanks[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev Releases a rank token for a player with a specific game rank. `player` is the address of the player. `gameRank` is the game rank of the player. `rankTokenAddress` is the address of the rank token contract.\\n     *\\n     * Modifies:\\n     *\\n     * - Unlocks one rank token of `gameRank` for `player` in the rank token contract.\\n     */\\n    function _releaseRankToken(address player, uint256 gameRank, address rankTokenAddress) private {\\n        IRankToken rankToken = IRankToken(rankTokenAddress);\\n        rankToken.unlock(player, gameRank, 1);\\n    }\\n\\n    /**\\n     * @dev Removes a player from a game and unlocks their rank tokens. `gameId` is the ID of the game. `player` is the address of the player to be removed.\\n     *\\n     * Requirements:\\n     *\\n     * - The game with `gameId` must exist.\\n     *\\n     * Modifies:\\n     *\\n     * - Removes `player` from the game.\\n     * - If the game rank is greater than 1, unlocks the game rank token for `player` in the rank token contract and unlocks each additional rank token for `player` in the respective rank token contracts.\\n     */\\n    function removeAndUnlockPlayer(uint256 gameId, address player) internal {\\n        enforceGameExists(gameId);\\n        gameId.removePlayer(player); //This will throw if game is in the process\\n        IRankifyInstanceCommons.RInstanceSettings storage settings = RInstanceStorage();\\n        IRankifyInstanceCommons.RInstance storage game = getGameStorage(gameId);\\n        if (game.rank > 1) {\\n            _releaseRankToken(player, game.rank, settings.rankTokenAddress);\\n            for (uint256 i = 0; i < game.additionalRanks.length; ++i) {\\n                _releaseRankToken(player, game.rank, game.additionalRanks[i]);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Tries to make a move for a player in a game. `gameId` is the ID of the game. `player` is the address of the player.\\n     * The \\\"move\\\" is considered to be a state when player has made all actions he could in the given turn.\\n     *\\n     * Requirements:\\n     *\\n     * - The game with `gameId` must exist.\\n     *\\n     * Modifies:\\n     *\\n     * - If the player has not voted and a vote is expected, or if the player has not made a proposal and a proposal is expected, does not make a move and returns `false`.\\n     * - Otherwise, makes a move for `player` and returns `true`.\\n     */\\n    function tryPlayerMove(uint256 gameId, address player) internal returns (bool) {\\n        uint256 turn = gameId.getTurn();\\n        IRankifyInstanceCommons.RInstanceSettings storage settings = RInstanceStorage();\\n        IRankifyInstanceCommons.RInstance storage game = getGameStorage(gameId);\\n        bool expectVote = true;\\n        bool expectProposal = true;\\n        if (turn == 1) expectVote = false; //Dont expect votes at firt turn\\n        // else if (gameId.isLastTurn()) expectProposal = false; // For now easiest solution is to keep collecting proposals as that is less complicated boundry case\\n        if (game.numPrevProposals < settings.voting.minQuadraticPositons) expectVote = false; // If there is not enough proposals then round is skipped votes cannot be filled\\n        bool madeMove = true;\\n        if (expectVote && !game.playerVoted[player]) madeMove = false;\\n        if (expectProposal && game.proposalCommitmentHashes[player] == \\\"\\\") madeMove = false;\\n        if (madeMove) gameId.playerMove(player);\\n        return madeMove;\\n    }\\n\\n    /**\\n     * @dev Calculates the scores using a quadratic formula based on the revealed votes and proposer indices. `gameId` is the ID of the game. `votesRevealed` is an array of revealed votes. `proposerIndicies` is an array of proposer indices that links proposals to index in getPlayers().\\n     *\\n     * Returns:\\n     *\\n     * - An array of updated scores for each player.\\n     * - An array of scores calculated for the current round.\\n     */\\n    function calculateScoresQuadratic(\\n        uint256 gameId,\\n        uint256[][] memory votesRevealed,\\n        uint256[] memory proposerIndicies\\n    ) internal returns (uint256[] memory, uint256[] memory) {\\n        address[] memory players = gameId.getPlayers();\\n        uint256[] memory scores = new uint256[](players.length);\\n        bool[] memory playerVoted = new bool[](players.length);\\n        IRankifyInstanceCommons.RInstanceSettings storage settings = RInstanceStorage();\\n        IRankifyInstanceCommons.RInstance storage game = getGameStorage(gameId);\\n        // Convert mappiing to array to pass it to libQuadratic\\n        for (uint256 i = 0; i < players.length; ++i) {\\n            playerVoted[i] = game.playerVoted[players[i]];\\n        }\\n        uint256[] memory roundScores = settings.voting.computeScoresByVPIndex(\\n            votesRevealed,\\n            playerVoted,\\n            settings.voting.maxQuadraticPoints,\\n            proposerIndicies.length\\n        );\\n        for (uint256 playerIdx = 0; playerIdx < players.length; playerIdx++) {\\n            //for each player\\n            if (proposerIndicies[playerIdx] < players.length) {\\n                //if player proposal exists\\n                scores[playerIdx] = gameId.getScore(players[playerIdx]) + roundScores[playerIdx];\\n                gameId.setScore(players[playerIdx], scores[playerIdx]);\\n            } else {\\n                //Player did not propose\\n            }\\n        }\\n        return (scores, roundScores);\\n    }\\n}\\n\",\"keccak256\":\"0xf4295953a01239293c94a48ca9a1aabf0b9924e404d07e8729f9956a3c938cd3\",\"license\":\"MIT\"},\"src/libraries/LibReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\n// import \\\"./LibDiamondOwner.sol\\\";\\n// import { IMultipass } from \\\"../interfaces/sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\nlibrary LibReentrancyGuard {\\n    bytes32 constant TBG_STORAGE_POSITION = keccak256(\\\"reentrancyguard.storage.position\\\");\\n\\n    struct ReentrancyGuardStruct {\\n        bool _entered;\\n    }\\n\\n    function reentrancyGuardStorage() internal pure returns (ReentrancyGuardStruct storage ds) {\\n        bytes32 position = TBG_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xfaad24b73bbcd004473dc16eccfefe6ab6b0f7204edbc286d8b8ce669bac742c\",\"license\":\"MIT\"},\"src/libraries/LibTurnBasedGame.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"hardhat/console.sol\\\";\\n// import {EnumerableMap} from \\\"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\\\";\\nimport {EnumerableSet} from \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {LibArray} from \\\"../libraries/LibArray.sol\\\";\\nimport {Math} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\n\\n/**\\n * @title LibTBG\\n * @dev Library for managing turn-based games.\\n * It is designed to be used as a base library for games, and provides the following functionality:\\n * - setting game settings such as time per turn, max players, min players, etc as well as perform score and leaderboard tracking\\n *\\n * Limitations:\\n * - It is assumed there is only one game per player\\n * - It is assumed there is only on game master per game\\n *\\n * ***WARNING*** Some limitations:\\n * - This library is still under development and its interfaces may change.\\n * - getting game data (which has own storage assigement and can be encapsulated from library) however there is no storage slot collision checks in place\\n *\\n */\\nlibrary LibTBG {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    struct GameSettings {\\n        uint256 timePerTurn;\\n        uint256 maxPlayersSize;\\n        uint256 minPlayersSize;\\n        uint256 timeToJoin;\\n        uint256 maxTurns;\\n        uint256 numWinners;\\n        uint256 voteCredits;\\n    }\\n\\n    struct GameInstance {\\n        address gameMaster;\\n        uint256 currentTurn;\\n        uint256 turnStartedAt;\\n        uint256 registrationOpenAt;\\n        bool hasStarted;\\n        bool hasEnded;\\n        EnumerableSet.AddressSet players;\\n        mapping(address => bool) madeMove;\\n        uint256 numPlayersMadeMove;\\n        mapping(address => uint256) score;\\n        bytes32 implemenationStoragePointer;\\n        bool isOvertime;\\n        address[] leaderboard;\\n    }\\n\\n    struct TBGStorageStruct {\\n        GameSettings settings;\\n        mapping(uint256 => GameInstance) games;\\n        mapping(address => uint256) playerInGame;\\n        uint256 totalGamesCreated;\\n    }\\n\\n    bytes32 constant TBG_STORAGE_POSITION = keccak256(\\\"turnbasedgame.storage.position\\\");\\n    bytes32 constant IMPLEMENTATION_STORAGE_POSITION = keccak256(\\\"implementation.turnbasedgame.storage.position\\\");\\n\\n    function TBGStorage() internal pure returns (TBGStorageStruct storage es) {\\n        bytes32 position = TBG_STORAGE_POSITION;\\n        assembly {\\n            es.slot := position\\n        }\\n    }\\n\\n    function _getGame(uint256 gameId) internal view returns (GameInstance storage) {\\n        TBGStorageStruct storage tbg = TBGStorage();\\n        return tbg.games[gameId];\\n    }\\n\\n    /**\\n     * @dev Initializes the game with the provided settings. `settings` is the settings for the game.\\n     *\\n     * Requirements:\\n     *\\n     * - `settings.timePerTurn` must not be zero.\\n     * - `settings.maxPlayersSize` must not be zero.\\n     * - `settings.minPlayersSize` must be at least 2.\\n     * - `settings.maxTurns` must not be zero.\\n     * - `settings.numWinners` must not be zero and must be less than `settings.minPlayersSize`.\\n     * - `settings.timeToJoin` must not be zero.\\n     * - `settings.maxPlayersSize` must not be less than `settings.minPlayersSize`.\\n     * Modifies:\\n     *\\n     * - Sets the settings of the game to `settings`.\\n     */\\n    function init(GameSettings memory settings) internal {\\n        TBGStorageStruct storage tbg = TBGStorage();\\n        if (settings.timePerTurn == 0) require(false, \\\"settings.timePerTurn\\\"); //  revert invalidConfiguration('timePerTurn');\\n        if (settings.maxPlayersSize == 0) require(false, \\\"settings.maxPlayersSize\\\"); // revert invalidConfiguration('maxPlayersSize');\\n        if (settings.minPlayersSize < 2) require(false, \\\"settings.minPlayersSize\\\"); //revert invalidConfiguration('minPlayersSize');\\n        if (settings.maxTurns == 0) require(false, \\\"settings.maxTurns\\\"); //revert invalidConfiguration('maxTurns');\\n        if (settings.numWinners == 0 || settings.numWinners >= settings.minPlayersSize) require(false, \\\"numWinners\\\"); //revert invalidConfiguration('numWinners');\\n        if (settings.timeToJoin == 0) require(false, \\\"timeToJoin\\\"); // revert invalidConfiguration('timeToJoin');\\n        if (settings.maxPlayersSize < settings.minPlayersSize) require(false, \\\"maxPlayersSize\\\"); //revert invalidConfiguration('maxPlayersSize');\\n\\n        tbg.settings = settings;\\n    }\\n\\n    /**\\n     * @dev Creates a new game with the provided game ID and game master. `gameId` is the ID of the game. `gm` is the address of the game master.\\n     *\\n     * Requirements:\\n     *\\n     * - The game with `gameId` must not already exist.\\n     * - `gm` must not be the zero address.\\n     * - `gameId` must not be zero.\\n     * - The game master of the game with `gameId` must be the zero address.\\n     *\\n     * Modifies:\\n     *\\n     * - Sets the game master of the game with `gameId` to `gm`.\\n     * - Increments the total number of games created.\\n     */\\n    function createGame(uint256 gameId, address gm) internal {\\n        TBGStorageStruct storage tbg = TBGStorage();\\n        require(!gameExists(gameId), \\\"createGame->Already exists\\\");\\n        require(gm != address(0), \\\"createGame->GM\\\");\\n        require(gameId != 0, \\\"createGame->gameId\\\");\\n        require(tbg.games[gameId].gameMaster == address(0), \\\"createGame->gameId\\\");\\n        tbg.games[gameId].gameMaster = gm;\\n        tbg.totalGamesCreated += 1;\\n\\n        //totalGamesCreated ensures nonce-like behaviur:\\n        //even if game would get deleted and re-created with same name, data storage would be different\\n        tbg.games[gameId].implemenationStoragePointer = keccak256(\\n            abi.encode(gameId, tbg.totalGamesCreated, TBG_STORAGE_POSITION)\\n        );\\n    }\\n\\n    /**\\n     * @dev Deletes a game with the provided game ID. `gameId` is the ID of the game.\\n     *\\n     * Requirements:\\n     *\\n     * - The game with `gameId` must exist.\\n     *\\n     * Modifies:\\n     *\\n     * - Sets the game master, current turn, hasEnded, hasStarted,\\n     *   implementationStoragePointer, isOvertime, leaderboard, numPlayersMadeMove,\\n     *   players, registrationOpenAt, and turnStartedAt of the game with `gameId`\\n     *   to their initial values.\\n     * - Sets the score and madeMove of each player in the game with `gameId`\\n     *   to their initial values.\\n     */\\n    function deleteGame(uint256 gameId) internal {\\n        TBGStorageStruct storage tbg = TBGStorage();\\n        GameInstance storage _game = _getGame(gameId);\\n        address[] memory players = _game.players.values();\\n        for (uint256 i = 0; i < players.length; ++i) {\\n            tbg.games[gameId].score[players[i]] = 0;\\n            tbg.games[gameId].madeMove[players[i]] = false;\\n        }\\n        delete tbg.games[gameId].gameMaster;\\n        delete tbg.games[gameId].currentTurn;\\n        delete tbg.games[gameId].hasEnded;\\n        delete tbg.games[gameId].hasStarted;\\n        delete tbg.games[gameId].implemenationStoragePointer;\\n        delete tbg.games[gameId].isOvertime;\\n        delete tbg.games[gameId].leaderboard;\\n        delete tbg.games[gameId].numPlayersMadeMove;\\n        delete tbg.games[gameId].players;\\n        delete tbg.games[gameId].registrationOpenAt;\\n        delete tbg.games[gameId].turnStartedAt;\\n    }\\n\\n    /**\\n     * @dev Checks if a game with the provided game ID can be joined. `gameId` is the ID of the game.\\n     *\\n     * Returns:\\n     *\\n     * - A boolean indicating whether the game can be joined.\\n     */\\n    function canBeJoined(uint256 gameId) internal view returns (bool) {\\n        GameInstance storage _game = _getGame(gameId);\\n        if (_game.hasStarted || _game.registrationOpenAt == 0) return false;\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Adds a player to a game with the provided game ID. `gameId` is the ID of the game. `participant` is the address of the player.\\n     *\\n     * Requirements:\\n     *\\n     * - The game with `gameId` must exist.\\n     * - `participant` must not already be in a game.\\n     * - The number of players in the game with `gameId` must be less than the maximum number of players.\\n     * - The game with `gameId` must be joinable.\\n     *\\n     * Modifies:\\n     *\\n     * - Adds `participant` to the players of the game with `gameId`.\\n     * - Sets the madeMove of `participant` in the game with `gameId` to false.\\n     * - Sets the game of `participant` to `gameId`.\\n     */\\n    function addPlayer(uint256 gameId, address participant) internal {\\n        TBGStorageStruct storage tbg = TBGStorage();\\n        require(gameExists(gameId), \\\"addPlayer->invalid game\\\");\\n\\n        require(tbg.playerInGame[participant] == 0, \\\"addPlayer->Player in game\\\");\\n        GameInstance storage _game = _getGame(gameId);\\n        require(_game.players.length() < tbg.settings.maxPlayersSize, \\\"addPlayer->party full\\\");\\n\\n        require(canBeJoined(gameId), \\\"addPlayer->cant join now\\\");\\n        _game.players.add(participant);\\n        _game.madeMove[participant] = false;\\n        tbg.playerInGame[participant] = gameId;\\n    }\\n\\n    /**\\n     * @dev Checks if a player is in a game with the provided game ID. `gameId` is the ID of the game. `player` is the address of the player.\\n     *\\n     * Returns:\\n     *\\n     * - A boolean indicating whether the player is in the game.\\n     */\\n    function isPlayerInGame(uint256 gameId, address player) internal view returns (bool) {\\n        TBGStorageStruct storage tbg = TBGStorage();\\n        return tbg.playerInGame[player] == gameId ? true : false;\\n    }\\n\\n    /**\\n     * @dev Removes a player from a game with the provided game ID. `gameId` is the ID of the game. `participant` is the address of the player.\\n     *\\n     * Requirements:\\n     *\\n     * - The game with `gameId` must exist.\\n     * - `participant` must be in the game with `gameId`.\\n     * - The game with `gameId` must not have started or must have ended.\\n     *\\n     * Modifies:\\n     *\\n     * - Sets the game of `participant` to 0.\\n     * - Removes `participant` from the players of the game with `gameId`.\\n     */\\n    function removePlayer(uint256 gameId, address participant) internal {\\n        TBGStorageStruct storage tbg = TBGStorage();\\n        GameInstance storage _game = _getGame(gameId);\\n        require(gameExists(gameId), \\\"game does not exist\\\");\\n        require(tbg.playerInGame[participant] == gameId, \\\"Not in the game\\\");\\n        require(_game.hasStarted == false || _game.hasEnded == true, \\\"Cannot leave once started\\\");\\n        tbg.playerInGame[participant] = 0;\\n        _game.players.remove(participant);\\n    }\\n\\n    /**\\n     * @dev Checks if the current turn in a game with the provided game ID has timed out. `gameId` is the ID of the game.\\n     *\\n     * Requirements:\\n     *\\n     * - `gameId` must not be zero.\\n     * - The game with `gameId` must have started.\\n     *\\n     * Returns:\\n     *\\n     * - A boolean indicating whether the current turn has timed out.\\n     */\\n    function isTurnTimedOut(uint256 gameId) internal view returns (bool) {\\n        TBGStorageStruct storage tbg = TBGStorage();\\n        GameInstance storage _game = _getGame(gameId);\\n        assert(gameId != 0);\\n        assert(_game.hasStarted == true);\\n        if (block.timestamp <= tbg.settings.timePerTurn + _game.turnStartedAt) return false;\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Checks if a game with the provided game ID exists. `gameId` is the ID of the game.\\n     *\\n     * Returns:\\n     *\\n     * - A boolean indicating whether the game exists.\\n     */\\n    function gameExists(uint256 gameId) internal view returns (bool) {\\n        GameInstance storage _game = _getGame(gameId);\\n        if (_game.gameMaster != address(0)) return true;\\n        return false;\\n    }\\n\\n    /**\\n     * @dev Enforces that a game with the provided game ID has started. `gameId` is the ID of the game.\\n     *\\n     * Requirements:\\n     *\\n     * - `gameId` must not be zero.\\n     * - The game with `gameId` must have started.\\n     */\\n    function enforceHasStarted(uint256 gameId) internal view {\\n        GameInstance storage _game = _getGame(gameId);\\n        assert(gameId != 0);\\n        require(_game.hasStarted, \\\"Game has not yet started\\\");\\n    }\\n\\n    /**\\n     * @dev Enforces that a game with the provided game ID has started. `gameId` is the ID of the game.\\n     *\\n     * Requirements:\\n     *\\n     * - `gameId` must not be zero.\\n     * - The game with `gameId` must have started.\\n     *\\n     */\\n    function canEndTurn(uint256 gameId) internal view returns (bool) {\\n        bool turnTimedOut = isTurnTimedOut(gameId);\\n        GameInstance storage _game = _getGame(gameId);\\n        if (!_game.hasStarted || isGameOver(gameId)) return false;\\n        if (turnTimedOut) return true;\\n        return false;\\n    }\\n\\n    /**\\n     * @dev Checks if the current turn in a game with the provided game ID can end early. `gameId` is the ID of the game.\\n     *\\n     * Returns:\\n     *\\n     * - A boolean indicating whether the current turn can end early.\\n     */\\n    function canEndTurnEarly(uint256 gameId) internal view returns (bool) {\\n        GameInstance storage _game = _getGame(gameId);\\n        bool everyoneMadeMove = (_game.numPlayersMadeMove) == _game.players.length() ? true : false;\\n        if (!_game.hasStarted || isGameOver(gameId)) return false;\\n        if (everyoneMadeMove || canEndTurn(gameId)) return true;\\n        return false;\\n    }\\n\\n    /**\\n     * @dev Modifier that requires the current turn in a game with the provided game ID to be able to end. `gameId` is the ID of the game.\\n     *\\n     * Requirements:\\n     *\\n     * - The current turn in the game with `gameId` must be able to end.\\n     */\\n    modifier onlyInTurnTime(uint256 gameId) {\\n        require(isTurnTimedOut(gameId) == false, \\\"onlyInTurnTime -> turn timedout\\\");\\n        _;\\n    }\\n\\n    modifier onlyWhenTurnCanEnd(uint256 gameId) {\\n        require(canEndTurn(gameId) == true, \\\"onlyWhenTurnCanEnd: Not everyone made a move yet and there still is time\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Clears the current moves in a game. `game` is the game.\\n     *\\n     * Modifies:\\n     *\\n     * - Sets the madeMove of each player in `game` to false.\\n     */\\n    function _clearCurrentMoves(GameInstance storage game) internal {\\n        for (uint256 i = 0; i < game.players.length(); ++i) {\\n            address player = game.players.at(i);\\n            game.madeMove[player] = false;\\n        }\\n        game.numPlayersMadeMove = 0;\\n    }\\n\\n    /**\\n     * @dev Resets the states of the players in a game. `game` is the game.\\n     *\\n     * Modifies:\\n     *\\n     * - Sets the madeMove and score of each player in `game` to their initial values.\\n     */\\n    function _resetPlayerStates(GameInstance storage game) internal {\\n        for (uint256 i = 0; i < game.players.length(); ++i) {\\n            address player = game.players.at(i);\\n            game.madeMove[player] = false;\\n            game.score[player] = 0;\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets the score of a player in a game with the provided game ID. `gameId` is the ID of the game. `player` is the address of the player. `value` is the score.\\n     *\\n     * Requirements:\\n     *\\n     * - `player` must be in the game with `gameId`.\\n     *\\n     * Modifies:\\n     *\\n     * - Sets the score of `player` in the game with `gameId` to `value`.\\n     */\\n    function setScore(uint256 gameId, address player, uint256 value) internal {\\n        GameInstance storage _game = _getGame(gameId);\\n        require(isPlayerInGame(gameId, player), \\\"player not in a game\\\");\\n        _game.score[player] = value;\\n    }\\n\\n    /**\\n     * @dev Gets the score of a player in a game with the provided game ID. `gameId` is the ID of the game. `player` is the address of the player.\\n     *\\n     * Returns:\\n     *\\n     * - The score of `player` in the game with `gameId`.\\n     */\\n    function getScore(uint256 gameId, address player) internal view returns (uint256) {\\n        GameInstance storage _game = _getGame(gameId);\\n        return _game.score[player];\\n    }\\n\\n    /**\\n     * @dev Gets the scores of the players in a game with the provided game ID. `gameId` is the ID of the game.\\n     *\\n     * Returns:\\n     *\\n     * - An array of the addresses of the players in the game with `gameId`.\\n     * - An array of the scores of the players in the game with `gameId`.\\n     */\\n    function getScores(uint256 gameId) internal view returns (address[] memory, uint256[] memory) {\\n        address[] memory players = getPlayers(gameId);\\n        uint256[] memory scores = new uint256[](players.length);\\n        for (uint256 i = 0; i < players.length; ++i) {\\n            scores[i] = getScore(gameId, players[i]);\\n        }\\n        return (players, scores);\\n    }\\n\\n    /**\\n     * @dev Opens registration for a game with the provided game ID. `gameId` is the ID of the game.\\n     *\\n     * Requirements:\\n     *\\n     * - The game with `gameId` must exist.\\n     *\\n     * Modifies:\\n     *\\n     * - Sets the registrationOpenAt of the game with `gameId` to the current block timestamp.\\n     */\\n    function openRegistration(uint256 gameId) internal {\\n        require(gameExists(gameId), \\\"game not found\\\");\\n        GameInstance storage _game = _getGame(gameId);\\n        _game.registrationOpenAt = block.timestamp;\\n    }\\n\\n    /**\\n     * @dev Checks if registration is open for a game with the provided game ID. `gameId` is the ID of the game.\\n     *\\n     * Returns:\\n     *\\n     * - A boolean indicating whether registration is open for the game.\\n     */\\n    function isRegistrationOpen(uint256 gameId) internal view returns (bool) {\\n        GameInstance storage _game = _getGame(gameId);\\n        TBGStorageStruct storage tbg = TBGStorage();\\n        if (_game.registrationOpenAt == 0) {\\n            return false;\\n        } else {\\n            return _game.registrationOpenAt < block.timestamp + tbg.settings.timeToJoin ? true : false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Checks if a game with the provided game ID can start. `gameId` is the ID of the game.\\n     *\\n     * Returns:\\n     *\\n     * - A boolean indicating whether the game can start.\\n     */\\n    function canStart(uint256 gameId) internal view returns (bool) {\\n        GameInstance storage _game = _getGame(gameId);\\n        TBGStorageStruct storage tbg = TBGStorage();\\n        if (_game.hasStarted) return false;\\n        if (_game.registrationOpenAt == 0) return false;\\n        if (gameId == 0) return false;\\n        if (block.timestamp <= _game.registrationOpenAt + tbg.settings.timeToJoin) return false;\\n        if (_game.players.length() < tbg.settings.minPlayersSize) return false;\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Checks if a game with the provided game ID can start early. `gameId` is the ID of the game.\\n     * By \\\"early\\\" it is assumed that time to join has not yet passed, but it's already cap players limit reached.\\n     *\\n     * Returns:\\n     *\\n     * - A boolean indicating whether the game can start early.\\n     */\\n    function canStartEarly(uint256 gameId) internal view returns (bool) {\\n        GameInstance storage _game = _getGame(gameId);\\n        TBGStorageStruct storage tbg = TBGStorage();\\n\\n        if ((_game.players.length() == tbg.settings.maxPlayersSize) || canStart(gameId)) return true;\\n        return false;\\n    }\\n\\n    /**\\n     * @dev Starts a game with the provided game ID early. `gameId` is the ID of the game.\\n     * By \\\"early\\\" it is assumed that time to join has not yet passed, but it's already cap players limit reached.\\n     *\\n     * Requirements:\\n     *\\n     * - The game with `gameId` must exist.\\n     * - The game with `gameId` must not have started.\\n     * - The game with `gameId` must have opened registration.\\n     * - The number of players in the game with `gameId` must be greater than or equal to the minimum number of players.\\n     * - The number of players in the game with `gameId` must be equal to the maximum number of players or the current block timestamp must be greater than the registration open time plus the time to join.\\n     *\\n     * Modifies:\\n     *\\n     * - Sets the hasStarted, hasEnded, currentTurn, and turnStartedAt of the game with `gameId` to their new values.\\n     * - Resets the states of the players in the game with `gameId`.\\n     */\\n    function startGameEarly(uint256 gameId) internal {\\n        GameInstance storage _game = _getGame(gameId);\\n        TBGStorageStruct storage tbg = TBGStorage();\\n        require(_game.hasStarted == false, \\\"startGame->already started\\\");\\n        require(_game.registrationOpenAt != 0, \\\"startGame->Game registration was not yet open\\\");\\n        require(gameId != 0, \\\"startGame->Game not found\\\");\\n        require(_game.players.length() >= tbg.settings.minPlayersSize, \\\"startGame->Not enough players\\\");\\n        require(\\n            (_game.players.length() == tbg.settings.maxPlayersSize) ||\\n                (block.timestamp > _game.registrationOpenAt + tbg.settings.timeToJoin),\\n            \\\"startGame->Not enough players\\\"\\n        );\\n        _game.hasStarted = true;\\n        _game.hasEnded = false;\\n        _game.currentTurn = 1;\\n        _game.turnStartedAt = block.timestamp;\\n        _resetPlayerStates(_game);\\n    }\\n\\n    /**\\n     * @dev Starts a game with the provided game ID. `gameId` is the ID of the game.\\n     *\\n     * Requirements:\\n     *\\n     * - The game with `gameId` must exist.\\n     * - The game with `gameId` must not have started.\\n     * - The game with `gameId` must have opened registration.\\n     * - The current block timestamp must be greater than the registration open time plus the time to join.\\n     *\\n     * Modifies:\\n     *\\n     * - Sets the hasStarted, hasEnded, currentTurn, and turnStartedAt of the game with `gameId` to their new values.\\n     * - Resets the states of the players in the game with `gameId`.\\n     */\\n    function startGame(uint256 gameId) internal {\\n        GameInstance storage _game = _getGame(gameId);\\n        TBGStorageStruct storage tbg = TBGStorage();\\n        require(_game.hasStarted == false, \\\"startGame->already started\\\");\\n        require(_game.registrationOpenAt != 0, \\\"startGame->Game registration was not yet open\\\");\\n        require(block.timestamp > _game.registrationOpenAt + tbg.settings.timeToJoin, \\\"startGame->Still Can Join\\\");\\n        require(gameId != 0, \\\"startGame->Game not found\\\");\\n        require(_game.players.length() >= tbg.settings.minPlayersSize, \\\"startGame->Not enough players\\\");\\n        _game.hasStarted = true;\\n        _game.hasEnded = false;\\n        _game.currentTurn = 1;\\n        _game.turnStartedAt = block.timestamp;\\n        _resetPlayerStates(_game);\\n    }\\n\\n    /**\\n     * @dev Gets the current turn of a game with the provided game ID. `gameId` is the ID of the game.\\n     *\\n     * Returns:\\n     *\\n     * - The current turn of the game with `gameId`.\\n     */\\n    function getTurn(uint256 gameId) internal view returns (uint256) {\\n        GameInstance storage _game = _getGame(gameId);\\n        return _game.currentTurn;\\n    }\\n\\n    /**\\n     * @dev Gets the game master of a game with the provided game ID. `gameId` is the ID of the game.\\n     *\\n     * Returns:\\n     *\\n     * - The game master of the game with `gameId`.\\n     */\\n    function getGM(uint256 gameId) internal view returns (address) {\\n        GameInstance storage _game = _getGame(gameId);\\n        return _game.gameMaster;\\n    }\\n\\n    /**\\n     * @dev Checks if the current turn is the last turn in a game with the provided game ID. `gameId` is the ID of the game.\\n     *\\n     * Returns:\\n     *\\n     * - A boolean indicating whether the current turn is the last turn in the game.\\n     */\\n    function isLastTurn(uint256 gameId) internal view returns (bool) {\\n        TBGStorageStruct storage tbg = TBGStorage();\\n        GameInstance storage _game = _getGame(gameId);\\n        if (_game.currentTurn == tbg.settings.maxTurns) return true;\\n        else return false;\\n    }\\n\\n    /**\\n     * @dev Checks if a game with the provided game ID is over. `gameId` is the ID of the game.\\n     *\\n     * Returns:\\n     *\\n     * - A boolean indicating whether the game is over.\\n     */\\n    function isGameOver(uint256 gameId) internal view returns (bool) {\\n        TBGStorageStruct storage tbg = TBGStorage();\\n        GameInstance storage _game = _getGame(gameId);\\n        if ((_game.currentTurn > tbg.settings.maxTurns) && !_game.isOvertime) return true;\\n        else return false;\\n    }\\n\\n    /**\\n     * @dev Enforces that a game with the provided game ID is not over. `gameId` is the ID of the game.\\n     *\\n     * Requirements:\\n     *\\n     * - The game with `gameId` must not be over.\\n     */\\n    function enforceIsNotOver(uint256 gameId) internal view {\\n        require(!isGameOver(gameId), \\\"Game over\\\");\\n    }\\n\\n    /**\\n     * @dev Records a player's move in a game with the provided game ID. `gameId` is the ID of the game. `player` is the address of the player.\\n     *\\n     * Requirements:\\n     *\\n     * - The game with `gameId` must have started.\\n     * - The game with `gameId` must not be over.\\n     * - `player` must not have made a move in the current turn of the game with `gameId`.\\n     * - `player` must be in the game with `gameId`.\\n     *\\n     * Modifies:\\n     *\\n     * - Sets the madeMove of `player` in the game with `gameId` to true.\\n     * - Increments the numPlayersMadeMove of the game with `gameId`.\\n     */\\n    function playerMove(uint256 gameId, address player) internal onlyInTurnTime(gameId) {\\n        GameInstance storage _game = _getGame(gameId);\\n        enforceHasStarted(gameId);\\n        enforceIsNotOver(gameId);\\n        require(_game.madeMove[player] == false, \\\"already made a move\\\");\\n        TBGStorageStruct storage tbg = TBGStorage();\\n        require(gameId == tbg.playerInGame[player], \\\"is not in the game\\\");\\n        _game.madeMove[player] = true;\\n        _game.numPlayersMadeMove += 1;\\n    }\\n\\n    function isPlayerTurnComplete(uint256 gameId, address player) internal view returns (bool) {\\n        GameInstance storage _game = _getGame(gameId);\\n        return _game.madeMove[player];\\n    }\\n\\n    /**\\n     * @dev Enforces that a player is in a game with the provided game ID. `gameId` is the ID of the game. `player` is the address of the player.\\n     *\\n     * Requirements:\\n     *\\n     * - `player` must be in the game with `gameId`.\\n     */\\n    function enforceIsPlayingGame(uint256 gameId, address player) internal view {\\n        TBGStorageStruct storage tbg = TBGStorage();\\n        require(gameId == tbg.playerInGame[player], \\\"is not in the game\\\");\\n    }\\n\\n    /**\\n     * @dev Checks if a game with the provided game ID has started. `gameId` is the ID of the game.\\n     *\\n     * Returns:\\n     *\\n     * - A boolean indicating whether the game has started.\\n     */\\n    function hasStarted(uint256 gameId) internal view returns (bool) {\\n        GameInstance storage _game = _getGame(gameId);\\n        return _game.hasStarted;\\n    }\\n\\n    /**\\n     * @dev Gets the leaderboard of a game with the provided game ID. `gameId` is the ID of the game.\\n     *\\n     * Returns:\\n     *\\n     * - An array of the addresses of the players in the game with `gameId`, sorted by score.\\n     */\\n    function getLeaderBoard(uint256 gameId) internal view returns (address[] memory) {\\n        GameInstance storage _game = _getGame(gameId);\\n        return _game.leaderboard;\\n    }\\n\\n    /**\\n     * @dev Advances to the next turn in a game with the provided game ID. `gameId` is the ID of the game.\\n     *\\n     * Requirements:\\n     *\\n     * - The game with `gameId` must be able to end the current turn early. (all players have moved or the turn has timed out)\\n     *\\n     * Modifies:\\n     *\\n     * - Clears the current moves in the game with `gameId`.\\n     * - Increments the currentTurn of the game with `gameId`.\\n     * - Sets the turnStartedAt of the game with `gameId` to the current block timestamp.\\n     * - If the current turn is the last turn or the game with `gameId` is in overtime, checks if the game is a tie and sets the isOvertime of the game with `gameId` to the result.\\n     * - Sets the hasEnded of the game with `gameId` to whether the game is over.\\n     *\\n     * Returns:\\n     *\\n     * - A boolean indicating whether the current turn is the last turn.\\n     * - A boolean indicating whether the game is a tie.\\n     * - A boolean indicating whether the game is over.\\n     */\\n    function nextTurn(uint256 gameId) internal returns (bool, bool, bool) {\\n        require(canEndTurnEarly(gameId), \\\"nextTurn->CanEndEarly\\\");\\n        GameInstance storage _game = _getGame(gameId);\\n        _clearCurrentMoves(_game);\\n        _game.currentTurn += 1;\\n        _game.turnStartedAt = block.timestamp;\\n        bool _isLastTurn = isLastTurn(gameId);\\n        if (_isLastTurn || _game.isOvertime) {\\n            bool _isTie = isTie(gameId);\\n            _game.isOvertime = _isTie;\\n        }\\n        _game.hasEnded = isGameOver(gameId);\\n\\n        (_game.leaderboard, ) = sortByScore(gameId);\\n        return (_isLastTurn, _game.isOvertime, _game.hasEnded);\\n    }\\n\\n    /**\\n     * @dev Gets the data storage pointer.\\n     *\\n     * Returns:\\n     *\\n     * - The data storage pointer.\\n     */\\n    function getDataStorage() internal pure returns (bytes32 pointer) {\\n        return IMPLEMENTATION_STORAGE_POSITION;\\n    }\\n\\n    /**\\n     * @dev Gets the game data storage pointer of a game with the provided game ID. `gameId` is the ID of the game.\\n     *\\n     * Returns:\\n     *\\n     * - The game data storage pointer of the game with `gameId`.\\n     */\\n    function getGameDataStorage(uint256 gameId) internal view returns (bytes32 pointer) {\\n        GameInstance storage _game = _getGame(gameId);\\n        return _game.implemenationStoragePointer;\\n    }\\n\\n    /**\\n     * @dev Gets the number of players in a game with the provided game ID. `gameId` is the ID of the game.\\n     *\\n     * Returns:\\n     *\\n     * - The number of players in the game with `gameId`.\\n     */\\n    function getPlayersNumber(uint256 gameId) internal view returns (uint256) {\\n        GameInstance storage _game = _getGame(gameId);\\n        return _game.players.length();\\n    }\\n\\n    /**\\n     * @dev Gets the players in a game with the provided game ID. `gameId` is the ID of the game.\\n     *\\n     * Returns:\\n     *\\n     * - An array of the addresses of the players in the game with `gameId`.\\n     */\\n    function getPlayers(uint256 gameId) internal view returns (address[] memory) {\\n        GameInstance storage _game = _getGame(gameId);\\n        return _game.players.values();\\n    }\\n\\n    /**\\n     * @dev Gets the game settings.\\n     *\\n     * Returns:\\n     *\\n     * - The game settings.\\n     */\\n    function getGameSettings() internal view returns (GameSettings memory) {\\n        TBGStorageStruct storage tbg = TBGStorage();\\n        return tbg.settings;\\n    }\\n\\n    /**\\n     * @dev Enforces that a game with the provided game ID is in the pre-registration stage. `gameId` is the ID of the game.\\n     *\\n     * Requirements:\\n     *\\n     * - Registration must not be open for the game with `gameId`.\\n     * - The game with `gameId` must not have started.\\n     */\\n    function enforceIsPreRegistrationStage(uint256 gameId) internal view {\\n        require(!isRegistrationOpen(gameId), \\\"Cannot do when registration is open\\\");\\n        require(!hasStarted(gameId), \\\"Cannot do when game started\\\");\\n    }\\n\\n    /**\\n     * @dev Adds overtime to a game with the provided game ID. `gameId` is the ID of the game.\\n     *\\n     * Modifies:\\n     *\\n     * - Sets the isOvertime of the game with `gameId` to true.\\n     */\\n    function addOvertime(uint256 gameId) internal {\\n        GameInstance storage _game = _getGame(gameId);\\n        _game.isOvertime = true;\\n    }\\n\\n    /**\\n     * @dev Checks if a game with the provided game ID is in overtime. `gameId` is the ID of the game.\\n     *\\n     * Returns:\\n     *\\n     * - A boolean indicating whether the game is in overtime.\\n     */\\n    function isOvertime(uint256 gameId) internal view returns (bool) {\\n        GameInstance storage _game = _getGame(gameId);\\n        return _game.isOvertime;\\n    }\\n\\n    /**\\n     * @dev Resets the overtime of a game with the provided game ID. `gameId` is the ID of the game.\\n     *\\n     * Modifies:\\n     *\\n     * - Sets the isOvertime of the game with `gameId` to false.\\n     */\\n    function resetOvertime(uint256 gameId) internal {\\n        GameInstance storage _game = _getGame(gameId);\\n        _game.isOvertime = false;\\n    }\\n\\n    /**\\n     * @dev Checks if a game with the provided game ID is a tie. `gameId` is the ID of the game.\\n     * Tie being defined as at least two of the top `numWinners` players having the same score.\\n     *\\n     * Returns:\\n     *\\n     * - A boolean indicating whether the game is a tie.\\n     */\\n    function isTie(uint256 gameId) internal view returns (bool) {\\n        TBGStorageStruct storage tbg = TBGStorage();\\n        (address[] memory players, uint256[] memory scores) = getScores(gameId);\\n\\n        LibArray.quickSort(scores, int256(0), int256(scores.length - 1));\\n        for (uint256 i = 0; i < players.length - 1; ++i) {\\n            if ((i <= tbg.settings.numWinners - 1)) {\\n                if (scores[i] == scores[i + 1]) {\\n                    return (true);\\n                }\\n            } else {\\n                break;\\n            }\\n        }\\n        return (false);\\n    }\\n\\n    /**\\n     * @dev Gets the game ID of the game a player is in. `player` is the address of the player.\\n     *\\n     * Returns:\\n     *\\n     * - The game ID of the game `player` is in.\\n     */\\n    function getPlayersGame(address player) internal view returns (uint256) {\\n        TBGStorageStruct storage tbg = TBGStorage();\\n\\n        return tbg.playerInGame[player];\\n    }\\n\\n    /**\\n     * @dev Sorts the players and scores arrays in descending order of scores using the quicksort algorithm. `players` is the array of player addresses. `scores` is the array of scores. `left` is the left index. `right` is the right index.\\n     *\\n     * Modifies:\\n     *\\n     * - Sorts the `players` and `scores` arrays in place.\\n     */\\n    function _quickSort(address[] memory players, uint256[] memory scores, int256 left, int256 right) private view {\\n        int256 i = left;\\n        int256 j = right;\\n        if (i == j) return;\\n        uint256 pivot = scores[uint256(left + (right - left) / 2)];\\n        while (i <= j) {\\n            while (scores[uint256(i)] > pivot) ++i;\\n            while (pivot > scores[uint256(j)]) j--;\\n            if (i <= j) {\\n                (scores[uint256(i)], scores[uint256(j)]) = (scores[uint256(j)], scores[uint256(i)]);\\n                (players[uint256(i)], players[uint256(j)]) = (players[uint256(j)], players[uint256(i)]);\\n                ++i;\\n                j--;\\n            }\\n        }\\n        if (left < j) _quickSort(players, scores, left, j);\\n        if (i < right) _quickSort(players, scores, i, right);\\n    }\\n\\n    /**\\n     * @dev Sorts the players in a game with the provided game ID by score in descending order. `gameId` is the ID of the game.\\n     *\\n     * Returns:\\n     *\\n     * - An array of the addresses of the players in the game with `gameId`, sorted by score.\\n     * - An array of the scores of the players in the game with `gameId`, sorted in descending order.\\n     */\\n    function sortByScore(uint256 gameId) internal view returns (address[] memory, uint256[] memory) {\\n        (address[] memory players, uint256[] memory scores) = getScores(gameId);\\n        _quickSort(players, scores, 0, int256(scores.length - 1));\\n        return (players, scores);\\n    }\\n}\\n\",\"keccak256\":\"0x8ec778a835477c1f54f9bf59068a271af885ee1a59106e1e511660a111eb63f5\",\"license\":\"MIT\"},\"src/mocks/MockERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\npragma solidity ^0.8.20;\\n\\ncontract MockERC20 is ERC20Burnable, Ownable {\\n    constructor(string memory name_, string memory symbol_, address owner) ERC20(name_, symbol_) Ownable(owner) {\\n        require(owner != address(0), \\\"must specify owner of the contract\\\");\\n        transferOwnership(owner);\\n    }\\n\\n    function mint(address to, uint256 amount) public onlyOwner {\\n        require(to != address(0), \\\"MockERC20->mint: Address not specified\\\");\\n        require(amount != 0, \\\"MockERC20->mint: amount not specified\\\");\\n        _mint(to, amount);\\n    }\\n}\\n\",\"keccak256\":\"0x6981606a9cd7ce51f4d1588e4bce396b9bbaee5b713275fe5789ac39d04af996\",\"license\":\"MIT\"},\"src/modifiers/OnlyOwnerDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\nimport \\\"../vendor/diamond/libraries/LibDiamond.sol\\\";\\n\\n// import \\\"./interfaces/IERC173.sol\\\";\\n\\ncontract OnlyOwnerDiamond {\\n    modifier onlyOwner() {\\n        LibDiamond.enforceIsContractOwner();\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0xbd7d10fcb4f303a983bb0526fea54b6968d90b45d0f383cae445b3c6d7144d58\",\"license\":\"MIT\"},\"src/vendor/diamond/DiamondCloneable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Adapted from the Diamond 3 reference implementation by Nick Mudge:\\n// https://github.com/mudgen/diamond-3-hardhat\\n\\nimport {LibDiamond} from \\\"./libraries/LibDiamond.sol\\\";\\nimport {IDiamondCut} from \\\"./interfaces/IDiamondCut.sol\\\";\\n\\ncontract DiamondCloneable {\\n    error fucntionDoesNotExist(bytes4 selector);\\n    address private immutable cutFacet;\\n\\n    constructor(address _contractOwner, address _diamondCutFacet) payable {\\n        cutFacet = _diamondCutFacet;\\n        addDiamondCutFacet(_contractOwner);\\n    }\\n\\n    function addDiamondCutFacet(address _contractOwner) private {\\n        LibDiamond.setContractOwner(_contractOwner);\\n        // Add the diamondCut external function from the diamondCutFacet\\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\\n        bytes4[] memory functionSelectors = new bytes4[](1);\\n\\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\\n        cut[0] = IDiamondCut.FacetCut({\\n            facetAddress: cutFacet,\\n            action: IDiamondCut.FacetCutAction.Add,\\n            functionSelectors: functionSelectors\\n        });\\n        LibDiamond.diamondCut(cut, address(0), \\\"\\\");\\n    }\\n\\n    // Find facet for function that is called and execute the\\n    // function if a facet is found and return any value.\\n    fallback() external payable {\\n        LibDiamond.DiamondStorage storage ds;\\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\\n        // get diamond storage\\n        assembly {\\n            ds.slot := position\\n        }\\n        // get facet from function selector\\n        address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\\n        if (facet == address(0)) {\\n            if (msg.sig == IDiamondCut.diamondCut.selector) {\\n                (IDiamondCut.FacetCut[] memory facets, address target, bytes memory data) = abi.decode(\\n                    msg.data[4:],\\n                    (IDiamondCut.FacetCut[], address, bytes)\\n                );\\n                // diamond was cloned, has no state\\n                // Owner is inferred from msg.sender\\n                addDiamondCutFacet(msg.sender);\\n                LibDiamond.diamondCut(facets, target, data);\\n                return;\\n            } else {\\n                revert fucntionDoesNotExist(msg.sig);\\n            }\\n        }\\n\\n        // Execute external function from facet using delegatecall and return any value.\\n        assembly {\\n            // copy function selector and any arguments\\n            calldatacopy(0, 0, calldatasize())\\n            // execute function call using the facet\\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\\n            // get any return value\\n            returndatacopy(0, 0, returndatasize())\\n            // return any return value or error back to the caller\\n            switch result\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    receive() external payable {}\\n}\\n\",\"keccak256\":\"0xabbc1a95450be6515442fe238964432fe3909f49f625025d65cb156c01db3473\",\"license\":\"MIT\"},\"src/vendor/diamond/facets/DiamondCutFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\nimport \\\"../interfaces/IDiamondCut.sol\\\";\\nimport \\\"../libraries/LibDiamond.sol\\\";\\n\\ncontract DiamondCutFacet is IDiamondCut {\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes memory _calldata) external override {\\n        LibDiamond.enforceIsContractOwner();\\n        LibDiamond.diamondCut(_diamondCut, _init, _calldata);\\n    }\\n}\\n\",\"keccak256\":\"0x5012040ef6d7de4ef15f52a4820727e4db76f6b61f657b55e4c1a68ab3423937\",\"license\":\"MIT\"},\"src/vendor/diamond/facets/DiamondLoupeFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\nimport \\\"../libraries/LibDiamond.sol\\\";\\nimport \\\"../interfaces/IDiamondLoupe.sol\\\";\\nimport \\\"../interfaces/IERC165.sol\\\";\\n\\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\\n    // Diamond Loupe Functions\\n    ////////////////////////////////////////////////////////////////////\\n    /// These functions are expected to be called frequently by tools.\\n    //\\n    // struct Facet {\\n    //     address facetAddress;\\n    //     bytes4[] functionSelectors;\\n    // }\\n\\n    /// @notice Gets all facets and their selectors.\\n    /// @return facets_ Facet\\n    function facets() external view override returns (Facet[] memory facets_) {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        uint256 numFacets = ds.facetAddresses.length;\\n        facets_ = new Facet[](numFacets);\\n        for (uint256 i; i < numFacets; ++i) {\\n            address facetAddress_ = ds.facetAddresses[i];\\n            facets_[i].facetAddress = facetAddress_;\\n            facets_[i].functionSelectors = ds.facetFunctionSelectors[facetAddress_].functionSelectors;\\n        }\\n    }\\n\\n    /// @notice Gets all the function selectors provided by a facet.\\n    /// @param _facet The facet address.\\n    /// @return facetFunctionSelectors_\\n    function facetFunctionSelectors(\\n        address _facet\\n    ) external view override returns (bytes4[] memory facetFunctionSelectors_) {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        facetFunctionSelectors_ = ds.facetFunctionSelectors[_facet].functionSelectors;\\n    }\\n\\n    /// @notice Get all the facet addresses used by a diamond.\\n    /// @return facetAddresses_\\n    function facetAddresses() external view override returns (address[] memory facetAddresses_) {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        facetAddresses_ = ds.facetAddresses;\\n    }\\n\\n    /// @notice Gets the facet that supports the given selector.\\n    /// @dev If facet is not found return address(0).\\n    /// @param _functionSelector The function selector.\\n    /// @return facetAddress_ The facet address.\\n    function facetAddress(bytes4 _functionSelector) external view override returns (address facetAddress_) {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        facetAddress_ = ds.selectorToFacetAndPosition[_functionSelector].facetAddress;\\n    }\\n\\n    // This implements ERC-165.\\n    function supportsInterface(bytes4 interfaceId) external view override returns (bool) {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        return ds.supportedInterfaces[interfaceId];\\n    }\\n}\\n\",\"keccak256\":\"0x18eb83104389775993aad9ec9c49737d13fd7afdcf32fc8b49bf7275e77141f1\",\"license\":\"MIT\"},\"src/vendor/diamond/facets/OwnershipFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport \\\"../libraries/LibDiamond.sol\\\";\\nimport \\\"../interfaces/IERC173.sol\\\";\\n\\ncontract OwnershipFacet is IERC173 {\\n    function transferOwnership(address _newOwner) external override {\\n        LibDiamond.enforceIsContractOwner();\\n        LibDiamond.setContractOwner(_newOwner);\\n    }\\n\\n    function owner() external view override returns (address) {\\n        return LibDiamond.contractOwner();\\n    }\\n}\\n\",\"keccak256\":\"0x8b0340a4ba86deff383c25ff4d95034aa9c11e048b82be7c9d839b7553c68cf9\",\"license\":\"MIT\"},\"src/vendor/diamond/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\n/******************************************************************************\\\\\\n*  Adapted from\\n*  Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {\\n        Add,\\n        Replace,\\n        Remove\\n    }\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\\n}\\n\",\"keccak256\":\"0x238f7bcdbbedfac48b94cbc9d4a15e16fb5c9c09fb41a8c72e2a7ff48c81f24b\",\"license\":\"MIT\"},\"src/vendor/diamond/interfaces/IDiamondLoupe.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\n// A loupe is a small magnifying glass used to look at diamonds.\\n// These functions look at diamonds\\ninterface IDiamondLoupe {\\n    /// These functions are expected to be called frequently\\n    /// by tools.\\n\\n    struct Facet {\\n        address facetAddress;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Gets all facet addresses and their four byte function selectors.\\n    /// @return facets_ Facet\\n    function facets() external view returns (Facet[] memory facets_);\\n\\n    /// @notice Gets all the function selectors supported by a specific facet.\\n    /// @param _facet The facet address.\\n    /// @return facetFunctionSelectors_\\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\\n\\n    /// @notice Get all the facet addresses used by a diamond.\\n    /// @return facetAddresses_\\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\\n\\n    /// @notice Gets the facet that supports the given selector.\\n    /// @dev If facet is not found return address(0).\\n    /// @param _functionSelector The function selector.\\n    /// @return facetAddress_ The facet address.\\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\\n}\\n\",\"keccak256\":\"0x5ce5cb670c85bea71036f7ce3513c9cf3df88d7f6fcfe8fbe74f8290be36a3cc\",\"license\":\"MIT\"},\"src/vendor/diamond/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\ninterface IERC165 {\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceId The interface identifier, as specified in ERC-165\\n    /// @dev Interface identification is specified in ERC-165. This function\\n    ///  uses less than 30,000 gas.\\n    /// @return `true` if the contract implements `interfaceID` and\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x0162f02752820fae5095e759db636e567ce9a128dd470e5b675a230a91f449c9\",\"license\":\"MIT\"},\"src/vendor/diamond/interfaces/IERC173.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\n/// @title ERC-173 Contract Ownership Standard\\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\\n/* is ERC165 */\\ninterface IERC173 {\\n    /// @dev This emits when ownership of a contract changes.\\n    // Removed deue to duplicate abi generation in 8.20 compiler\\n    // event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// @notice Get the address of the owner\\n    /// @return owner_ The address of the owner.\\n    function owner() external view returns (address owner_);\\n\\n    /// @notice Set the address of the new owner of the contract\\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\\n    /// @param _newOwner The address of the new owner of the contract\\n    function transferOwnership(address _newOwner) external;\\n}\\n\",\"keccak256\":\"0x8fd517ec0fdb014cb7d32a0b46894899e7e1113dba0e62d1b85c492a3c70a2c0\",\"license\":\"MIT\"},\"src/vendor/diamond/libraries/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Adapted from the Diamond 3 reference implementation by Nick Mudge:\\n// https://github.com/mudgen/diamond-3-hardhat\\n\\nimport {IDiamondCut} from \\\"../interfaces/IDiamondCut.sol\\\";\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    struct DiamondStorage {\\n        // maps function selector to the facet address and\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    // Internal function version of diamondCut\\n    function diamondCut(IDiamondCut.FacetCut[] memory _diamondCut, address _init, bytes memory _calldata) internal {\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else {\\n                revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress != _facetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n            removeFunction(ds, oldFacetAddress, selector);\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        // if function does not exist then do nothing and return\\n        require(_facetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            removeFunction(ds, oldFacetAddress, selector);\\n        }\\n    }\\n\\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: New facet has no code\\\");\\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\\n        ds.facetAddresses.push(_facetAddress);\\n    }\\n\\n    function addFunction(\\n        DiamondStorage storage ds,\\n        bytes4 _selector,\\n        uint96 _selectorPosition,\\n        address _facetAddress\\n    ) internal {\\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n    }\\n\\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n        // an immutable function is a function defined directly in a diamond\\n        require(_facetAddress != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\\n        // if not the same then replace _selector with lastSelector\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\\n        }\\n        // delete the last selector\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n        delete ds.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n            if (facetAddressPosition != lastFacetAddressPosition) {\\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\\n            }\\n            ds.facetAddresses.pop();\\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n        }\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            require(_calldata.length == 0, \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\");\\n        } else {\\n            // this is removed in order to work with ethereum distribution system\\n            // require(_calldata.length > 0, \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\");\\n            if (_init != address(this)) {\\n                enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0xd9a8bbcd696d08fecdfe299f90684c459226c8b06698de84010c5f08093cba1d\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6102206040523480156200001257600080fd5b5060405162006a9b38038062006a9b833981016040819052620000359162000255565b306000801b8b8260006040516200004c9062000204565b604051809103906000f08015801562000069573d6000803e3d6000fd5b509050600082826040516200007e9062000212565b6001600160a01b03928316815291166020820152604001604051809103906000f080158015620000b2573d6000803e3d6000fd5b506001600160a01b031660805250620000df91505073c0d31d398c5ee86c5f8a23fa253ee8a586da03ce90565b6001600160a01b0316638eaa6ac0836040518263ffffffff1660e01b81526004016200010d91815260200190565b602060405180830381865afa1580156200012b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620001519190620003bf565b6001600160a01b0390811660a0526001600160e01b031990911660c0528d81166101c05289811660e052888116610100528781166101205286811661014052858116610160528481166101805283166101a05250506101e0899052620001ee88600081604001516001600160801b0316608083602001516001600160401b0316901b60c084600001516001600160401b0316901b17179050919050565b6102005250620003e49950505050505050505050565b6116dc80620026c783390190565b612cf88062003da383390190565b80516001600160a01b03811681146200023857600080fd5b919050565b80516001600160401b03811681146200023857600080fd5b60008060008060008060008060008060008b8d036101a08112156200027957600080fd5b620002848d62000220565b60208e0151909c506001600160e01b031981168114620002a357600080fd5b60408e0151909b5099506060605f1982011215620002c057600080fd5b50604051606081016001600160401b0381118282101715620002f257634e487b7160e01b600052604160045260246000fd5b6040526200030360608e016200023d565b81526200031360808e016200023d565b602082015260a08d01516001600160801b03811681146200033357600080fd5b604082015297506200034860c08d0162000220565b96506200035860e08d0162000220565b9550620003696101008d0162000220565b94506200037a6101208d0162000220565b93506200038b6101408d0162000220565b92506200039c6101608d0162000220565b9150620003ad6101808d0162000220565b90509295989b509295989b9093969950565b600060208284031215620003d257600080fd5b620003dd8262000220565b9392505050565b60805160a05160c05160e05161010051610120516101405161016051610180516101a0516101c0516101e0516102005161223162000496600039600081816119020152611ce60152600081816118df0152611cc301526000611592015260006114d8015260006113cd015260006110e101526000610f8601526000610e2b015260006104cf015260006103c401526000611b6c0152600081816101260152611c260152600061198d01526122316000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c80636d4ce63c146100465780639ca33c9e14610066578063e8a3d48514610079575b600080fd5b61004e61008e565b60405161005d93929190611ddc565b60405180910390f35b61004e610074366004611e17565b6101c9565b610081611933565b60405161005d9190611f18565b6060600080600061009d611961565b5050604080516002808252606082018352929350600092909160208301908036833701905050905081516001146100d6576100d6611f32565b816000815181106100e9576100e9611f48565b60200260200101518160008151811061010457610104611f48565b60200260200101906001600160a01b031690816001600160a01b0316815250507f00000000000000000000000000000000000000000000000000000000000000008160018151811061015857610158611f48565b6001600160a01b0390921660209283029190910182015260405183916101a291017f496e697469616c697a65644469616d6f6e64446973747269627574696f6e00008152601e0190565b6040516020818303038152906040526101ba90611f5e565b60009450945094505050909192565b606060008060006101d8611a2f565b505090506000816000815181106101f1576101f1611f48565b602002602001015190506000600867ffffffffffffffff81111561021757610217611e01565b60405190808252806020026020018201604052801561026457816020015b604080516060808201835260008083526020830152918101919091528152602001906001900390816102355790505b5060408051600480825260a082019092529192506000919060208201608080368337019050509050637a0ed62760e01b816000815181106102a7576102a7611f48565b6001600160e01b03199092166020928302919091019091015280517fadfca15e0000000000000000000000000000000000000000000000000000000090829060019081106102f7576102f7611f48565b6001600160e01b03199092166020928302919091019091015280517f52ef6b2c00000000000000000000000000000000000000000000000000000000908290600290811061034757610347611f48565b6001600160e01b03199092166020928302919091019091015280517fcdffacc600000000000000000000000000000000000000000000000000000000908290600390811061039757610397611f48565b6001600160e01b031990921660209283029190910182015260408051606081019091526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016815290810160008152602001828152508260008151811061040757610407611f48565b60209081029190910101526040805160028082526060820190925260009181602001602082028036833701905050905063d3a8018d60e01b8160008151811061045257610452611f48565b6001600160e01b03199092166020928302919091019091015280517f6cbadbfa0000000000000000000000000000000000000000000000000000000090829060019081106104a2576104a2611f48565b6001600160e01b031990921660209283029190910182015260408051606081019091526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016815290810160008152602001828152508360018151811061051257610512611f48565b602090810291909101015260408051601c8082526103a082019092526000918160200160208202803683370190505090506369958ab960e01b8160008151811061055e5761055e611f48565b6001600160e01b03199092166020928302919091019091015280517faee5f34a0000000000000000000000000000000000000000000000000000000090829060019081106105ae576105ae611f48565b6001600160e01b0319909216602092830291909101820152604080516060810190915260238082526105ec926121ac90830139805160209091012090565b816002815181106105ff576105ff611f48565b6001600160e01b03199092166020928302919091018201526040805160608101909152602d80825261063d926121cf90830139805160209091012090565b8160038151811061065057610650611f48565b6001600160e01b031990921660209283029190910182015260408051808201909152601b81527f63726561746547616d6528616464726573732c75696e743235362900000000009101527f07ead9304ed4c506629fd3beab7ecc0f07c2ade3fb42eb798fed46a8e7dacffb816004815181106106ce576106ce611f48565b6001600160e01b03199092166020928302919091019091015280517f3feef58a00000000000000000000000000000000000000000000000000000000908290600590811061071e5761071e611f48565b6001600160e01b03199092166020928302919091019091015280517fefaa55a000000000000000000000000000000000000000000000000000000000908290600690811061076e5761076e611f48565b6001600160e01b03199092166020928302919091019091015280517fcca84a0c0000000000000000000000000000000000000000000000000000000090829060079081106107be576107be611f48565b6001600160e01b03199092166020928302919091019091015280517fe5ed1d5900000000000000000000000000000000000000000000000000000000908290600890811061080e5761080e611f48565b6001600160e01b03199092166020928302919091019091015280517fbc197c8100000000000000000000000000000000000000000000000000000000908290600990811061085e5761085e611f48565b6001600160e01b03199092166020928302919091019091015280517ff23a6e6100000000000000000000000000000000000000000000000000000000908290600a9081106108ae576108ae611f48565b6001600160e01b03199092166020928302919091019091015280517f150b7a0200000000000000000000000000000000000000000000000000000000908290600b9081106108fe576108fe611f48565b6001600160e01b03199092166020928302919091019091015280517f7f4e484900000000000000000000000000000000000000000000000000000000908290600c90811061094e5761094e611f48565b6001600160e01b03199092166020928302919091019091015280517fb55991c000000000000000000000000000000000000000000000000000000000908290600d90811061099e5761099e611f48565b6001600160e01b03199092166020928302919091019091015280517ff72ea46700000000000000000000000000000000000000000000000000000000908290600e9081106109ee576109ee611f48565b6001600160e01b03199092166020928302919091019091015280517f04527d9000000000000000000000000000000000000000000000000000000000908290600f908110610a3e57610a3e611f48565b6001600160e01b03199092166020928302919091019091015280517f9637460e000000000000000000000000000000000000000000000000000000009082906010908110610a8e57610a8e611f48565b6001600160e01b03199092166020928302919091019091015280517f8eed01f8000000000000000000000000000000000000000000000000000000009082906011908110610ade57610ade611f48565b6001600160e01b03199092166020928302919091019091015280517fbfa64036000000000000000000000000000000000000000000000000000000009082906012908110610b2e57610b2e611f48565b6001600160e01b03199092166020928302919091019091015280517fb881cffe000000000000000000000000000000000000000000000000000000009082906013908110610b7e57610b7e611f48565b6001600160e01b03199092166020928302919091019091015280517f4024ba75000000000000000000000000000000000000000000000000000000009082906014908110610bce57610bce611f48565b6001600160e01b03199092166020928302919091019091015280517f9a214b1e000000000000000000000000000000000000000000000000000000009082906015908110610c1e57610c1e611f48565b6001600160e01b03199092166020928302919091019091015280517f460e2049000000000000000000000000000000000000000000000000000000009082906016908110610c6e57610c6e611f48565b6001600160e01b03199092166020928302919091019091015280517f392b749c000000000000000000000000000000000000000000000000000000009082906017908110610cbe57610cbe611f48565b6001600160e01b03199092166020928302919091019091015280517f58759df7000000000000000000000000000000000000000000000000000000009082906018908110610d0e57610d0e611f48565b6001600160e01b03199092166020928302919091019091015280517f8d3b80b3000000000000000000000000000000000000000000000000000000009082906019908110610d5e57610d5e611f48565b6001600160e01b03199092166020928302919091019091015280517fde83804800000000000000000000000000000000000000000000000000000000908290601a908110610dae57610dae611f48565b6001600160e01b03199092166020928302919091019091015280517f3528dff700000000000000000000000000000000000000000000000000000000908290601b908110610dfe57610dfe611f48565b6001600160e01b031990921660209283029190910182015260408051606081019091526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000168152908101600081526020018281525084600281518110610e6e57610e6e611f48565b60209081029190910101526040805160038082526080820190925260009181602001602082028036833701905050905063bbb294f860e01b81600081518110610eb957610eb9611f48565b6001600160e01b03199092166020928302919091019091015280517fbf0f2d7e000000000000000000000000000000000000000000000000000000009082906001908110610f0957610f09611f48565b6001600160e01b03199092166020928302919091019091015280517f8f298b2a000000000000000000000000000000000000000000000000000000009082906002908110610f5957610f59611f48565b6001600160e01b031990921660209283029190910182015260408051606081019091526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000168152908101600081526020018281525085600381518110610fc957610fc9611f48565b602090810291909101015260408051600380825260808201909252600091816020016020820280368337019050509050636a99473560e01b8160008151811061101457611014611f48565b6001600160e01b03199092166020928302919091019091015280517f463bc35500000000000000000000000000000000000000000000000000000000908290600190811061106457611064611f48565b6001600160e01b03199092166020928302919091019091015280517f0c6446d50000000000000000000000000000000000000000000000000000000090829060029081106110b4576110b4611f48565b6001600160e01b031990921660209283029190910182015260408051606081019091526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016815290810160008152602001828152508660048151811061112457611124611f48565b602090810291909101015260408051600880825261012082019092526000918160200160208202803683370190505090506326126d4660e01b8160008151811061117057611170611f48565b6001600160e01b03199092166020928302919091019091015280517f59db5bf70000000000000000000000000000000000000000000000000000000090829060019081106111c0576111c0611f48565b6001600160e01b03199092166020928302919091019091015280517f869dc02100000000000000000000000000000000000000000000000000000000908290600290811061121057611210611f48565b6001600160e01b03199092166020928302919091019091015280517fc94b01da00000000000000000000000000000000000000000000000000000000908290600390811061126057611260611f48565b6001600160e01b03199092166020928302919091019091015280517f865173410000000000000000000000000000000000000000000000000000000090829060049081106112b0576112b0611f48565b6001600160e01b03199092166020928302919091019091015280517f924b5bb100000000000000000000000000000000000000000000000000000000908290600590811061130057611300611f48565b6001600160e01b03199092166020928302919091019091015280517f911f8e1b00000000000000000000000000000000000000000000000000000000908290600690811061135057611350611f48565b6001600160e01b03199092166020928302919091019091015280517f966fb1ea0000000000000000000000000000000000000000000000000000000090829060079081106113a0576113a0611f48565b6001600160e01b031990921660209283029190910182015260408051606081019091526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016815290810160008152602001828152508760058151811061141057611410611f48565b60209081029190910101526040805160028082526060820190925260009181602001602082028036833701905050905063f2fde38b60e01b8160008151811061145b5761145b611f48565b6001600160e01b03199092166020928302919091019091015280517f8da5cb5b0000000000000000000000000000000000000000000000000000000090829060019081106114ab576114ab611f48565b6001600160e01b031990921660209283029190910182015260408051606081019091526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016815290810160008152602001828152508860068151811061151b5761151b611f48565b6020908102919091010152604080516001808252818301909252600091816020016020820280368337019050509050631eea6f8960e01b8160008151811061156557611565611f48565b6001600160e01b031990921660209283029190910182015260408051606081019091526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001681529081016000815260200182815250896007815181106115d5576115d5611f48565b60200260200101819052506115fa8a8a60405180602001604052806000815250611b4b565b604080516009808252610140820190925260009160208201610120803683370190505090508a8160008151811061163357611633611f48565b60200260200101906001600160a01b031690816001600160a01b0316815250508960008151811061166657611666611f48565b6020026020010151600001518160018151811061168557611685611f48565b60200260200101906001600160a01b031690816001600160a01b031681525050896001815181106116b8576116b8611f48565b602002602001015160000151816002815181106116d7576116d7611f48565b60200260200101906001600160a01b031690816001600160a01b0316815250508960028151811061170a5761170a611f48565b6020026020010151600001518160038151811061172957611729611f48565b60200260200101906001600160a01b031690816001600160a01b0316815250508960038151811061175c5761175c611f48565b6020026020010151600001518160048151811061177b5761177b611f48565b60200260200101906001600160a01b031690816001600160a01b031681525050896004815181106117ae576117ae611f48565b602002602001015160000151816005815181106117cd576117cd611f48565b60200260200101906001600160a01b031690816001600160a01b0316815250508960058151811061180057611800611f48565b6020026020010151600001518160068151811061181f5761181f611f48565b60200260200101906001600160a01b031690816001600160a01b0316815250508960068151811061185257611852611f48565b6020026020010151600001518160078151811061187157611871611f48565b60200260200101906001600160a01b031690816001600160a01b031681525050896007815181106118a4576118a4611f48565b602002602001015160000151816008815181106118c3576118c3611f48565b6001600160a01b0392909216602092830291909101909101529f7f00000000000000000000000000000000000000000000000000000000000000009f507f00000000000000000000000000000000000000000000000000000000000000009e509c50505050505050505050505050565b606061193d611c88565b60405160200161194d9190611f85565b604051602081830303815290604052905090565b6040805160018082528183019092526060916000918291829190602080830190803683370190505090507f0000000000000000000000000000000000000000000000000000000000000000816000815181106119bf576119bf611f48565b6001600160a01b039092166020928302919091018201526040518291611a0991017f4469616d6f6e64446973747269627574696f6e00000000000000000000000000815260130190565b604051602081830303815290604052611a2190611f5e565b600093509350935050909192565b60606000806000806000611a41611caf565b825192955090935091508067ffffffffffffffff811115611a6457611a64611e01565b604051908082528060200260200182016040528015611a8d578160200160208202803683370190505b50965060005b81811015611afd576000611abf868381518110611ab257611ab2611f48565b6020026020010151611d0d565b905080898381518110611ad457611ad4611f48565b6001600160a01b039092166020928302919091019091015250611af681611fec565b9050611a93565b50336001600160a01b03167fe3cc25159981d843f19d5a7611997a66ca6e772edd134fb611c7b29aded7bb8a88604051611b379190612014565b60405180910390a250949590949350915050565b600080825111611b6a5760405180602001604052806000815250611be4565b7f000000000000000000000000000000000000000000000000000000000000000082604051602401611b9c9190611f18565b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff166001600160e01b0319909316929092179091525b6040517f1f931c1c0000000000000000000000000000000000000000000000000000000081529091506001600160a01b03851690631f931c1c90611c509086907f0000000000000000000000000000000000000000000000000000000000000000908690600401612027565b600060405180830381600087803b158015611c6a57600080fd5b505af1158015611c7e573d6000803e3d6000fd5b5050505050505050565b6060611c9f60408051602081019091526000815290565b60405160200161194d9190612144565b60606000806000611cbe611961565b5090957f000000000000000000000000000000000000000000000000000000000000000095507f0000000000000000000000000000000000000000000000000000000000000000945092505050565b6000763d602d80600a3d3981f3363d3d373d3d3d363d730000008260601b60e81c176000526e5af43d82803e903d91602b57fd5bf38260781b17602052603760096000f090506001600160a01b038116611d93576040517fc2f868f400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b919050565b600081518084526020808501945080840160005b83811015611dd15781516001600160a01b031687529582019590820190600101611dac565b509495945050505050565b606081526000611def6060830186611d98565b60208301949094525060400152919050565b634e487b7160e01b600052604160045260246000fd5b600060208284031215611e2957600080fd5b813567ffffffffffffffff80821115611e4157600080fd5b818401915084601f830112611e5557600080fd5b813581811115611e6757611e67611e01565b604051601f8201601f19908116603f01168101908382118183101715611e8f57611e8f611e01565b81604052828152876020848701011115611ea857600080fd5b826020860160208301376000928101602001929092525095945050505050565b60005b83811015611ee3578181015183820152602001611ecb565b50506000910152565b60008151808452611f04816020860160208601611ec8565b601f01601f19169290920160200192915050565b602081526000611f2b6020830184611eec565b9392505050565b634e487b7160e01b600052600160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b80516020808301519190811015611f7f576000198160200360031b1b821691505b50919050565b60008251611f97818460208701611ec8565b7f3b000000000000000000000000000000000000000000000000000000000000009201918252507f4172677561626c65566f74696e67546f75726e616d656e7400000000000000006001820152601901919050565b6000600019820361200d57634e487b7160e01b600052601160045260246000fd5b5060010190565b602081526000611f2b6020830184611d98565b60006060808301818452808751808352608092508286019150828160051b8701016020808b0160005b84811015612114577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff808a850301865281518885016001600160a01b03825116865284820151600381106120b357634e487b7160e01b600052602160045260246000fd5b868601526040918201519186018a905281519081905290840190600090898701905b808310156120ff5783516001600160e01b03191682529286019260019290920191908601906120d5565b50978501979550505090820190600101612050565b50506001600160a01b038a169088015286810360408801526121368189611eec565b9a9950505050505050505050565b60008251612156818460208701611ec8565b7f3b000000000000000000000000000000000000000000000000000000000000009201918252507f496e697469616c697a65644469616d6f6e64446973747269627574696f6e00006001820152601f0191905056fe63726561746547616d6528616464726573732c75696e743235362c75696e743235362963726561746547616d6528616464726573732c75696e743235362c75696e743235362c616464726573735b5d29a2646970667358221220532dcaeb52c1f08b316968efb199d6295c21b7b76fe14f92c6054f65e8c6851264736f6c63430008140033608060405234801561001057600080fd5b506116bc806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c80631f931c1c14610030575b600080fd5b61004361003e3660046111ce565b610045565b005b61004d610067565b61006161005a848661129d565b8383610110565b50505050565b7fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c600401546001600160a01b0316331461010e5760405162461bcd60e51b815260206004820152602260248201527f4c69624469616d6f6e643a204d75737420626520636f6e7472616374206f776e60448201527f657200000000000000000000000000000000000000000000000000000000000060648201526084015b60405180910390fd5b565b60005b83518110156102ec576000848281518110610130576101306113e1565b602002602001015160200151905060006002811115610151576101516113f7565b816002811115610163576101636113f7565b036101b1576101ac85838151811061017d5761017d6113e1565b60200260200101516000015186848151811061019b5761019b6113e1565b602002602001015160400151610337565b6102d9565b60018160028111156101c5576101c56113f7565b0361020e576101ac8583815181106101df576101df6113e1565b6020026020010151600001518684815181106101fd576101fd6113e1565b60200260200101516040015161061f565b6002816002811115610222576102226113f7565b0361026b576101ac85838151811061023c5761023c6113e1565b60200260200101516000015186848151811061025a5761025a6113e1565b602002602001015160400151610910565b60405162461bcd60e51b815260206004820152602760248201527f4c69624469616d6f6e644375743a20496e636f7272656374204661636574437560448201527f74416374696f6e000000000000000000000000000000000000000000000000006064820152608401610105565b50806102e481611423565b915050610113565b507f8faa70878671ccd212d20771b795c50af8fd3ff6cf27f4bde57e5d4de0aeb6738383836040516103209392919061148d565b60405180910390a16103328282610a97565b505050565b60008151116103ae5760405162461bcd60e51b815260206004820152602b60248201527f4c69624469616d6f6e644375743a204e6f2073656c6563746f727320696e206660448201527f6163657420746f206375740000000000000000000000000000000000000000006064820152608401610105565b7fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c6001600160a01b03831661044b5760405162461bcd60e51b815260206004820152602c60248201527f4c69624469616d6f6e644375743a204164642066616365742063616e2774206260448201527f65206164647265737328302900000000000000000000000000000000000000006064820152608401610105565b6001600160a01b0383166000908152600182016020526040812054906bffffffffffffffffffffffff82169003610486576104868285610c44565b60005b83518110156106185760008482815181106104a6576104a66113e1565b6020908102919091018101516001600160e01b031981166000908152918690526040909120549091506001600160a01b0316801561054c5760405162461bcd60e51b815260206004820152603560248201527f4c69624469616d6f6e644375743a2043616e2774206164642066756e6374696f60448201527f6e207468617420616c72656164792065786973747300000000000000000000006064820152608401610105565b6001600160e01b0319821660008181526020878152604080832080546001600160a01b03908116600160a01b6bffffffffffffffffffffffff8c16021782558c168085526001808c0185529285208054938401815585528385206008840401805463ffffffff60079095166004026101000a948502191660e08a901c949094029390931790925593909252879052815473ffffffffffffffffffffffffffffffffffffffff191617905583610600816115aa565b9450505050808061061090611423565b915050610489565b5050505050565b60008151116106965760405162461bcd60e51b815260206004820152602b60248201527f4c69624469616d6f6e644375743a204e6f2073656c6563746f727320696e206660448201527f6163657420746f206375740000000000000000000000000000000000000000006064820152608401610105565b7fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c6001600160a01b0383166107335760405162461bcd60e51b815260206004820152602c60248201527f4c69624469616d6f6e644375743a204164642066616365742063616e2774206260448201527f65206164647265737328302900000000000000000000000000000000000000006064820152608401610105565b6001600160a01b0383166000908152600182016020526040812054906bffffffffffffffffffffffff8216900361076e5761076e8285610c44565b60005b835181101561061857600084828151811061078e5761078e6113e1565b6020908102919091018101516001600160e01b031981166000908152918690526040909120549091506001600160a01b0390811690871681036108395760405162461bcd60e51b815260206004820152603860248201527f4c69624469616d6f6e644375743a2043616e2774207265706c6163652066756e60448201527f6374696f6e20776974682073616d652066756e6374696f6e00000000000000006064820152608401610105565b610844858284610cbb565b6001600160e01b0319821660008181526020878152604080832080546001600160a01b03908116600160a01b6bffffffffffffffffffffffff8c16021782558c168085526001808c0185529285208054938401815585528385206008840401805463ffffffff60079095166004026101000a948502191660e08a901c949094029390931790925593909252879052815473ffffffffffffffffffffffffffffffffffffffff1916179055836108f8816115aa565b9450505050808061090890611423565b915050610771565b60008151116109875760405162461bcd60e51b815260206004820152602b60248201527f4c69624469616d6f6e644375743a204e6f2073656c6563746f727320696e206660448201527f6163657420746f206375740000000000000000000000000000000000000000006064820152608401610105565b7fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c6001600160a01b03831615610a255760405162461bcd60e51b815260206004820152603660248201527f4c69624469616d6f6e644375743a2052656d6f7665206661636574206164647260448201527f657373206d7573742062652061646472657373283029000000000000000000006064820152608401610105565b60005b8251811015610061576000838281518110610a4557610a456113e1565b6020908102919091018101516001600160e01b031981166000908152918590526040909120549091506001600160a01b0316610a82848284610cbb565b50508080610a8f90611423565b915050610a28565b6001600160a01b038216610b1e57805115610b1a5760405162461bcd60e51b815260206004820152603c60248201527f4c69624469616d6f6e644375743a205f696e697420697320616464726573732860448201527f3029206275745f63616c6c64617461206973206e6f7420656d707479000000006064820152608401610105565b5050565b6001600160a01b0382163014610b5057610b508260405180606001604052806028815260200161163b602891396110b1565b600080836001600160a01b031683604051610b6b91906115d5565b600060405180830381855af49150503d8060008114610ba6576040519150601f19603f3d011682016040523d82523d6000602084013e610bab565b606091505b50915091508161006157805115610bd6578060405162461bcd60e51b815260040161010591906115f1565b60405162461bcd60e51b815260206004820152602660248201527f4c69624469616d6f6e644375743a205f696e69742066756e6374696f6e20726560448201527f76657274656400000000000000000000000000000000000000000000000000006064820152608401610105565b610c6681604051806060016040528060248152602001611663602491396110b1565b6002820180546001600160a01b03909216600081815260019485016020908152604082208601859055948401835591825292902001805473ffffffffffffffffffffffffffffffffffffffff19169091179055565b6001600160a01b038216610d375760405162461bcd60e51b815260206004820152603760248201527f4c69624469616d6f6e644375743a2043616e27742072656d6f76652066756e6360448201527f74696f6e207468617420646f65736e27742065786973740000000000000000006064820152608401610105565b306001600160a01b03831603610db55760405162461bcd60e51b815260206004820152602e60248201527f4c69624469616d6f6e644375743a2043616e27742072656d6f766520696d6d7560448201527f7461626c652066756e6374696f6e0000000000000000000000000000000000006064820152608401610105565b6001600160e01b03198116600090815260208481526040808320546001600160a01b0386168452600180880190935290832054600160a01b9091046bffffffffffffffffffffffff169291610e099161160b565b9050808214610f00576001600160a01b03841660009081526001860160205260408120805483908110610e3e57610e3e6113e1565b600091825260208083206008830401546001600160a01b038916845260018a019091526040909220805460079092166004026101000a90920460e01b925082919085908110610e8f57610e8f6113e1565b600091825260208083206008830401805463ffffffff60079094166004026101000a938402191660e09590951c929092029390931790556001600160e01b03199290921682528690526040902080546001600160a01b0316600160a01b6bffffffffffffffffffffffff8516021790555b6001600160a01b03841660009081526001860160205260409020805480610f2957610f29611624565b60008281526020808220600860001990940193840401805463ffffffff600460078716026101000a0219169055919092556001600160e01b03198516825286905260408120819055819003610618576002850154600090610f8c9060019061160b565b6001600160a01b0386166000908152600180890160205260409091200154909150808214611048576000876002018381548110610fcb57610fcb6113e1565b6000918252602090912001546002890180546001600160a01b039092169250829184908110610ffc57610ffc6113e1565b6000918252602080832091909101805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b03948516179055929091168152600189810190925260409020018190555b8660020180548061105b5761105b611624565b600082815260208082208301600019908101805473ffffffffffffffffffffffffffffffffffffffff191690559092019092556001600160a01b0388168252600189810190915260408220015550505050505050565b813b81816100615760405162461bcd60e51b815260040161010591906115f1565b80356001600160a01b03811681146110e957600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b6040516060810167ffffffffffffffff81118282101715611127576111276110ee565b60405290565b604051601f8201601f1916810167ffffffffffffffff81118282101715611156576111566110ee565b604052919050565b600082601f83011261116f57600080fd5b813567ffffffffffffffff811115611189576111896110ee565b61119c6020601f19601f8401160161112d565b8181528460208386010111156111b157600080fd5b816020850160208301376000918101602001919091529392505050565b600080600080606085870312156111e457600080fd5b843567ffffffffffffffff808211156111fc57600080fd5b818701915087601f83011261121057600080fd5b81358181111561121f57600080fd5b8860208260051b850101111561123457600080fd5b6020830196508095505061124a602088016110d2565b9350604087013591508082111561126057600080fd5b5061126d8782880161115e565b91505092959194509250565b600067ffffffffffffffff821115611293576112936110ee565b5060051b60200190565b60006112b06112ab84611279565b61112d565b83815260208082019190600586811b8601368111156112ce57600080fd5b865b818110156113d457803567ffffffffffffffff808211156112f15760008081fd5b818a019150606082360312156113075760008081fd5b61130f611104565b611318836110d2565b8152868301356003811061132c5760008081fd5b81880152604083810135838111156113445760008081fd5b939093019236601f85011261135b57600092508283fd5b8335925061136b6112ab84611279565b83815292871b840188019288810190368511156113885760008081fd5b948901945b848610156113bd5785356001600160e01b0319811681146113ae5760008081fd5b8252948901949089019061138d565b9183019190915250885250509483019483016112d0565b5092979650505050505050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052602160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b600060001982036114365761143661140d565b5060010190565b60005b83811015611458578181015183820152602001611440565b50506000910152565b6000815180845261147981602086016020860161143d565b601f01601f19169290920160200192915050565b60006060808301818452808751808352608092508286019150828160051b8701016020808b0160005b8481101561157a577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff808a850301865281518885016001600160a01b038251168652848201516003811061151957634e487b7160e01b600052602160045260246000fd5b868601526040918201519186018a905281519081905290840190600090898701905b808310156115655783516001600160e01b031916825292860192600192909201919086019061153b565b509785019795505050908201906001016114b6565b50506001600160a01b038a1690880152868103604088015261159c8189611461565b9a9950505050505050505050565b60006bffffffffffffffffffffffff8083168181036115cb576115cb61140d565b6001019392505050565b600082516115e781846020870161143d565b9190910192915050565b6020815260006116046020830184611461565b9392505050565b8181038181111561161e5761161e61140d565b92915050565b634e487b7160e01b600052603160045260246000fdfe4c69624469616d6f6e644375743a205f696e6974206164647265737320686173206e6f20636f64654c69624469616d6f6e644375743a204e657720666163657420686173206e6f20636f6465a26469706673582212208dfddeca5a793d32c146b4bfca0e8e1c32a2091e17d98823dbfb609c232b139f64736f6c6343000814003360a060405260405162002cf838038062002cf88339810160408190526200002691620010fc565b6001600160a01b0381166080526200003e8262000046565b50506200138a565b620000518162000163565b604080516001808252818301909252600091816020015b60408051606080820183526000808352602083015291810191909152815260200190600190039081620000685750506040805160018082528183019092529192506000919060208083019080368337019050509050631f931c1c60e01b81600081518110620000db57620000db62001134565b6001600160e01b031990921660209283029190910182015260408051606081019091526080516001600160a01b0316815290810160008152602001828152508260008151811062000130576200013062001134565b60200260200101819052506200015e82600060405180602001604052806000815250620001e760201b60201c565b505050565b7fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c132080546001600160a01b031981166001600160a01b0384811691821790935560405160008051602062002c4c833981519152939092169182907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a3505050565b60005b8351811015620003f35760008482815181106200020b576200020b62001134565b6020026020010151602001519050600060028111156200022f576200022f6200114a565b8160028111156200024457620002446200114a565b03620002a2576200029c85838151811062000263576200026362001134565b60200260200101516000015186848151811062000284576200028462001134565b6020026020010151604001516200043d60201b60201c565b620003dd565b6001816002811115620002b957620002b96200114a565b0362000311576200029c858381518110620002d857620002d862001134565b602002602001015160000151868481518110620002f957620002f962001134565b602002602001015160400151620006ca60201b60201c565b60028160028111156200032857620003286200114a565b0362000380576200029c85838151811062000347576200034762001134565b60200260200101516000015186848151811062000368576200036862001134565b6020026020010151604001516200096260201b60201c565b60405162461bcd60e51b815260206004820152602760248201527f4c69624469616d6f6e644375743a20496e636f727265637420466163657443756044820152663a20b1ba34b7b760c91b60648201526084015b60405180910390fd5b5080620003ea8162001176565b915050620001ea565b507f8faa70878671ccd212d20771b795c50af8fd3ff6cf27f4bde57e5d4de0aeb6738383836040516200042993929190620011e6565b60405180910390a16200015e828262000ac8565b6000815111620004935760405162461bcd60e51b815260206004820152602b602482015260008051602062002cd883398151915260448201526a1858d95d081d1bc818dd5d60aa1b6064820152608401620003d4565b60008051602062002c4c8339815191526001600160a01b038316620004ff5760405162461bcd60e51b815260206004820152602c602482015260008051602062002c9483398151915260448201526b65206164647265737328302960a01b6064820152608401620003d4565b6001600160a01b0383166000908152600182016020526040812054906001600160601b0382169003620005385762000538828562000c6e565b60005b8351811015620006c35760008482815181106200055c576200055c62001134565b6020908102919091018101516001600160e01b031981166000908152918690526040909120549091506001600160a01b03168015620006045760405162461bcd60e51b815260206004820152603560248201527f4c69624469616d6f6e644375743a2043616e2774206164642066756e6374696f60448201527f6e207468617420616c72656164792065786973747300000000000000000000006064820152608401620003d4565b6001600160e01b0319821660008181526020878152604080832080546001600160a01b03908116600160a01b6001600160601b038c16021782558c168085526001808c0185529285208054938401815585528385206008840401805463ffffffff60079095166004026101000a948502191660e08a901c94909402939093179092559390925287905281546001600160a01b03191617905583620006a881620012ed565b94505050508080620006ba9062001176565b9150506200053b565b5050505050565b6000815111620007205760405162461bcd60e51b815260206004820152602b602482015260008051602062002cd883398151915260448201526a1858d95d081d1bc818dd5d60aa1b6064820152608401620003d4565b60008051602062002c4c8339815191526001600160a01b0383166200078c5760405162461bcd60e51b815260206004820152602c602482015260008051602062002c9483398151915260448201526b65206164647265737328302960a01b6064820152608401620003d4565b6001600160a01b0383166000908152600182016020526040812054906001600160601b0382169003620007c557620007c5828562000c6e565b60005b8351811015620006c3576000848281518110620007e957620007e962001134565b6020908102919091018101516001600160e01b031981166000908152918690526040909120549091506001600160a01b039081169087168103620008965760405162461bcd60e51b815260206004820152603860248201527f4c69624469616d6f6e644375743a2043616e2774207265706c6163652066756e60448201527f6374696f6e20776974682073616d652066756e6374696f6e00000000000000006064820152608401620003d4565b620008a385828462000cdb565b6001600160e01b0319821660008181526020878152604080832080546001600160a01b03908116600160a01b6001600160601b038c16021782558c168085526001808c0185529285208054938401815585528385206008840401805463ffffffff60079095166004026101000a948502191660e08a901c94909402939093179092559390925287905281546001600160a01b031916179055836200094781620012ed565b94505050508080620009599062001176565b915050620007c8565b6000815111620009b85760405162461bcd60e51b815260206004820152602b602482015260008051602062002cd883398151915260448201526a1858d95d081d1bc818dd5d60aa1b6064820152608401620003d4565b60008051602062002c4c8339815191526001600160a01b0383161562000a475760405162461bcd60e51b815260206004820152603660248201527f4c69624469616d6f6e644375743a2052656d6f7665206661636574206164647260448201527f657373206d7573742062652061646472657373283029000000000000000000006064820152608401620003d4565b60005b825181101562000ac257600083828151811062000a6b5762000a6b62001134565b6020908102919091018101516001600160e01b031981166000908152918590526040909120549091506001600160a01b031662000aaa84828462000cdb565b5050808062000ab99062001176565b91505062000a4a565b50505050565b6001600160a01b03821662000b525780511562000b4e5760405162461bcd60e51b815260206004820152603c60248201527f4c69624469616d6f6e644375743a205f696e697420697320616464726573732860448201527f3029206275745f63616c6c64617461206973206e6f7420656d707479000000006064820152608401620003d4565b5050565b6001600160a01b038216301462000b885762000b888260405180606001604052806028815260200162002c6c60289139620010bb565b600080836001600160a01b03168360405162000ba591906200131e565b600060405180830381855af49150503d806000811462000be2576040519150601f19603f3d011682016040523d82523d6000602084013e62000be7565b606091505b50915091508162000ac25780511562000c16578060405162461bcd60e51b8152600401620003d491906200133c565b60405162461bcd60e51b815260206004820152602660248201527f4c69624469616d6f6e644375743a205f696e69742066756e6374696f6e2072656044820152651d995c9d195960d21b6064820152608401620003d4565b62000c938160405180606001604052806024815260200162002cb460249139620010bb565b6002820180546001600160a01b0390921660008181526001948501602090815260408220860185905594840183559182529290200180546001600160a01b0319169091179055565b6001600160a01b03821662000d595760405162461bcd60e51b815260206004820152603760248201527f4c69624469616d6f6e644375743a2043616e27742072656d6f76652066756e6360448201527f74696f6e207468617420646f65736e27742065786973740000000000000000006064820152608401620003d4565b306001600160a01b0383160362000dca5760405162461bcd60e51b815260206004820152602e60248201527f4c69624469616d6f6e644375743a2043616e27742072656d6f766520696d6d7560448201526d3a30b1363290333ab731ba34b7b760911b6064820152608401620003d4565b6001600160e01b03198116600090815260208481526040808320546001600160a01b0386168452600180880190935290832054600160a01b9091046001600160601b0316929162000e1b9162001358565b905080821462000f14576001600160a01b0384166000908152600186016020526040812080548390811062000e545762000e5462001134565b600091825260208083206008830401546001600160a01b038916845260018a019091526040909220805460079092166004026101000a90920460e01b92508291908590811062000ea85762000ea862001134565b600091825260208083206008830401805463ffffffff60079094166004026101000a938402191660e09590951c929092029390931790556001600160e01b03199290921682528690526040902080546001600160a01b0316600160a01b6001600160601b038516021790555b6001600160a01b0384166000908152600186016020526040902080548062000f405762000f4062001374565b60008281526020808220600860001990940193840401805463ffffffff600460078716026101000a0219169055919092556001600160e01b03198516825286905260408120819055819003620006c357600285015460009062000fa69060019062001358565b6001600160a01b03861660009081526001808901602052604090912001549091508082146200105c57600087600201838154811062000fe95762000fe962001134565b6000918252602090912001546002890180546001600160a01b0390921692508291849081106200101d576200101d62001134565b600091825260208083209190910180546001600160a01b0319166001600160a01b03948516179055929091168152600189810190925260409020018190555b8660020180548062001072576200107262001374565b60008281526020808220830160001990810180546001600160a01b03191690559092019092556001600160a01b0388168252600189810190915260408220015550505050505050565b813b818162000ac25760405162461bcd60e51b8152600401620003d491906200133c565b80516001600160a01b0381168114620010f757600080fd5b919050565b600080604083850312156200111057600080fd5b6200111b83620010df565b91506200112b60208401620010df565b90509250929050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052602160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b6000600182016200118b576200118b62001160565b5060010190565b60005b83811015620011af57818101518382015260200162001195565b50506000910152565b60008151808452620011d281602086016020860162001192565b601f01601f19169290920160200192915050565b60006060808301818452808751808352608092508286019150828160051b8701016020808b0160005b84811015620012bb57898403607f19018652815180516001600160a01b031685528381015189860190600381106200125757634e487b7160e01b600052602160045260246000fd5b868601526040918201519186018a905281519081905290840190600090898701905b80831015620012a55783516001600160e01b031916825292860192600192909201919086019062001279565b509785019795505050908201906001016200120f565b50506001600160a01b038a16908801528681036040880152620012df8189620011b8565b9a9950505050505050505050565b60006001600160601b038281166002600160601b0319810162001314576200131462001160565b6001019392505050565b600082516200133281846020870162001192565b9190910192915050565b602081526000620013516020830184620011b8565b9392505050565b818103818111156200136e576200136e62001160565b92915050565b634e487b7160e01b600052603160045260246000fd5b6080516118a6620013a660003960006101e901526118a66000f3fe60806040523661000b57005b600080356001600160e01b03191681527fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c602081905260409091205481906001600160a01b031680610109577fe06ce3e4000000000000000000000000000000000000000000000000000000006000356001600160e01b031916016100c4576000808061009b36600481846112bc565b8101906100a89190611412565b9250925092506100b73361012d565b6100c2838383610257565b005b6040517fceb54e7c0000000000000000000000000000000000000000000000000000000081526001600160e01b03196000351660048201526024015b60405180910390fd5b3660008037600080366000845af43d6000803e808015610128573d6000f35b3d6000fd5b61013681610479565b604080516001808252818301909252600091816020015b6040805160608082018352600080835260208301529181019190915281526020019060019003908161014d5750506040805160018082528183019092529192506000919060208083019080368337019050509050631f931c1c60e01b816000815181106101bc576101bc6115cb565b6001600160e01b031990921660209283029190910182015260408051606081019091526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016815290810160008152602001828152508260008151811061022c5761022c6115cb565b602002602001018190525061025282600060405180602001604052806000815250610257565b505050565b60005b8351811015610433576000848281518110610277576102776115cb565b602002602001015160200151905060006002811115610298576102986115e1565b8160028111156102aa576102aa6115e1565b036102f8576102f38583815181106102c4576102c46115cb565b6020026020010151600001518684815181106102e2576102e26115cb565b60200260200101516040015161051b565b610420565b600181600281111561030c5761030c6115e1565b03610355576102f3858381518110610326576103266115cb565b602002602001015160000151868481518110610344576103446115cb565b602002602001015160400151610803565b6002816002811115610369576103696115e1565b036103b2576102f3858381518110610383576103836115cb565b6020026020010151600001518684815181106103a1576103a16115cb565b602002602001015160400151610af4565b60405162461bcd60e51b815260206004820152602760248201527f4c69624469616d6f6e644375743a20496e636f7272656374204661636574437560448201527f74416374696f6e000000000000000000000000000000000000000000000000006064820152608401610100565b508061042b8161160d565b91505061025a565b507f8faa70878671ccd212d20771b795c50af8fd3ff6cf27f4bde57e5d4de0aeb67383838360405161046793929190611677565b60405180910390a16102528282610c81565b7fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c1320805473ffffffffffffffffffffffffffffffffffffffff1981166001600160a01b038481169182179093556040517fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c939092169182907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a3505050565b60008151116105925760405162461bcd60e51b815260206004820152602b60248201527f4c69624469616d6f6e644375743a204e6f2073656c6563746f727320696e206660448201527f6163657420746f206375740000000000000000000000000000000000000000006064820152608401610100565b7fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c6001600160a01b03831661062f5760405162461bcd60e51b815260206004820152602c60248201527f4c69624469616d6f6e644375743a204164642066616365742063616e2774206260448201527f65206164647265737328302900000000000000000000000000000000000000006064820152608401610100565b6001600160a01b0383166000908152600182016020526040812054906bffffffffffffffffffffffff8216900361066a5761066a8285610e2e565b60005b83518110156107fc57600084828151811061068a5761068a6115cb565b6020908102919091018101516001600160e01b031981166000908152918690526040909120549091506001600160a01b031680156107305760405162461bcd60e51b815260206004820152603560248201527f4c69624469616d6f6e644375743a2043616e2774206164642066756e6374696f60448201527f6e207468617420616c72656164792065786973747300000000000000000000006064820152608401610100565b6001600160e01b0319821660008181526020878152604080832080546001600160a01b03908116600160a01b6bffffffffffffffffffffffff8c16021782558c168085526001808c0185529285208054938401815585528385206008840401805463ffffffff60079095166004026101000a948502191660e08a901c949094029390931790925593909252879052815473ffffffffffffffffffffffffffffffffffffffff1916179055836107e481611794565b945050505080806107f49061160d565b91505061066d565b5050505050565b600081511161087a5760405162461bcd60e51b815260206004820152602b60248201527f4c69624469616d6f6e644375743a204e6f2073656c6563746f727320696e206660448201527f6163657420746f206375740000000000000000000000000000000000000000006064820152608401610100565b7fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c6001600160a01b0383166109175760405162461bcd60e51b815260206004820152602c60248201527f4c69624469616d6f6e644375743a204164642066616365742063616e2774206260448201527f65206164647265737328302900000000000000000000000000000000000000006064820152608401610100565b6001600160a01b0383166000908152600182016020526040812054906bffffffffffffffffffffffff82169003610952576109528285610e2e565b60005b83518110156107fc576000848281518110610972576109726115cb565b6020908102919091018101516001600160e01b031981166000908152918690526040909120549091506001600160a01b039081169087168103610a1d5760405162461bcd60e51b815260206004820152603860248201527f4c69624469616d6f6e644375743a2043616e2774207265706c6163652066756e60448201527f6374696f6e20776974682073616d652066756e6374696f6e00000000000000006064820152608401610100565b610a28858284610ea5565b6001600160e01b0319821660008181526020878152604080832080546001600160a01b03908116600160a01b6bffffffffffffffffffffffff8c16021782558c168085526001808c0185529285208054938401815585528385206008840401805463ffffffff60079095166004026101000a948502191660e08a901c949094029390931790925593909252879052815473ffffffffffffffffffffffffffffffffffffffff191617905583610adc81611794565b94505050508080610aec9061160d565b915050610955565b6000815111610b6b5760405162461bcd60e51b815260206004820152602b60248201527f4c69624469616d6f6e644375743a204e6f2073656c6563746f727320696e206660448201527f6163657420746f206375740000000000000000000000000000000000000000006064820152608401610100565b7fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c6001600160a01b03831615610c095760405162461bcd60e51b815260206004820152603660248201527f4c69624469616d6f6e644375743a2052656d6f7665206661636574206164647260448201527f657373206d7573742062652061646472657373283029000000000000000000006064820152608401610100565b60005b8251811015610c7b576000838281518110610c2957610c296115cb565b6020908102919091018101516001600160e01b031981166000908152918590526040909120549091506001600160a01b0316610c66848284610ea5565b50508080610c739061160d565b915050610c0c565b50505050565b6001600160a01b038216610d0857805115610d045760405162461bcd60e51b815260206004820152603c60248201527f4c69624469616d6f6e644375743a205f696e697420697320616464726573732860448201527f3029206275745f63616c6c64617461206973206e6f7420656d707479000000006064820152608401610100565b5050565b6001600160a01b0382163014610d3a57610d3a826040518060600160405280602881526020016118256028913961129b565b600080836001600160a01b031683604051610d5591906117bf565b600060405180830381855af49150503d8060008114610d90576040519150601f19603f3d011682016040523d82523d6000602084013e610d95565b606091505b509150915081610c7b57805115610dc0578060405162461bcd60e51b815260040161010091906117db565b60405162461bcd60e51b815260206004820152602660248201527f4c69624469616d6f6e644375743a205f696e69742066756e6374696f6e20726560448201527f76657274656400000000000000000000000000000000000000000000000000006064820152608401610100565b610e508160405180606001604052806024815260200161184d6024913961129b565b6002820180546001600160a01b03909216600081815260019485016020908152604082208601859055948401835591825292902001805473ffffffffffffffffffffffffffffffffffffffff19169091179055565b6001600160a01b038216610f215760405162461bcd60e51b815260206004820152603760248201527f4c69624469616d6f6e644375743a2043616e27742072656d6f76652066756e6360448201527f74696f6e207468617420646f65736e27742065786973740000000000000000006064820152608401610100565b306001600160a01b03831603610f9f5760405162461bcd60e51b815260206004820152602e60248201527f4c69624469616d6f6e644375743a2043616e27742072656d6f766520696d6d7560448201527f7461626c652066756e6374696f6e0000000000000000000000000000000000006064820152608401610100565b6001600160e01b03198116600090815260208481526040808320546001600160a01b0386168452600180880190935290832054600160a01b9091046bffffffffffffffffffffffff169291610ff3916117f5565b90508082146110ea576001600160a01b03841660009081526001860160205260408120805483908110611028576110286115cb565b600091825260208083206008830401546001600160a01b038916845260018a019091526040909220805460079092166004026101000a90920460e01b925082919085908110611079576110796115cb565b600091825260208083206008830401805463ffffffff60079094166004026101000a938402191660e09590951c929092029390931790556001600160e01b03199290921682528690526040902080546001600160a01b0316600160a01b6bffffffffffffffffffffffff8516021790555b6001600160a01b038416600090815260018601602052604090208054806111135761111361180e565b60008281526020808220600860001990940193840401805463ffffffff600460078716026101000a0219169055919092556001600160e01b031985168252869052604081208190558190036107fc576002850154600090611176906001906117f5565b6001600160a01b03861660009081526001808901602052604090912001549091508082146112325760008760020183815481106111b5576111b56115cb565b6000918252602090912001546002890180546001600160a01b0390921692508291849081106111e6576111e66115cb565b6000918252602080832091909101805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b03948516179055929091168152600189810190925260409020018190555b866002018054806112455761124561180e565b600082815260208082208301600019908101805473ffffffffffffffffffffffffffffffffffffffff191690559092019092556001600160a01b0388168252600189810190915260408220015550505050505050565b813b8181610c7b5760405162461bcd60e51b815260040161010091906117db565b600080858511156112cc57600080fd5b838611156112d957600080fd5b5050820193919092039150565b634e487b7160e01b600052604160045260246000fd5b6040516060810167ffffffffffffffff8111828210171561131f5761131f6112e6565b60405290565b604051601f8201601f1916810167ffffffffffffffff8111828210171561134e5761134e6112e6565b604052919050565b600067ffffffffffffffff821115611370576113706112e6565b5060051b60200190565b6001600160a01b038116811461138f57600080fd5b50565b803561139d8161137a565b919050565b600082601f8301126113b357600080fd5b813567ffffffffffffffff8111156113cd576113cd6112e6565b6113e06020601f19601f84011601611325565b8181528460208386010111156113f557600080fd5b816020850160208301376000918101602001919091529392505050565b60008060006060848603121561142757600080fd5b67ffffffffffffffff808535111561143e57600080fd5b8435850186601f82011261145157600080fd5b61146361145e8235611356565b611325565b81358082526020808301929160051b8401018981111561148257600080fd5b602084015b8181101561158c57858135111561149d57600080fd5b803585016060601f19828e030112156114b557600080fd5b6114bd6112fc565b60208201356114cb8161137a565b81526040820135600381106114df57600080fd5b60208201526060820135888111156114f657600080fd5b8083019250508c603f83011261150b57600080fd5b602082013561151c61145e82611356565b81815260059190911b83016040019060208101908f83111561153d57600080fd5b6040850194505b828510156115765784356001600160e01b031981161461156357600080fd5b8435825260209485019490910190611544565b6040840152505085525060209384019301611487565b50508096505050506115a060208601611392565b92506040850135818111156115b457600080fd5b6115c0878288016113a2565b925050509250925092565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052602160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b60006000198203611620576116206115f7565b5060010190565b60005b8381101561164257818101518382015260200161162a565b50506000910152565b60008151808452611663816020860160208601611627565b601f01601f19169290920160200192915050565b60006060808301818452808751808352608092508286019150828160051b8701016020808b0160005b84811015611764577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff808a850301865281518885016001600160a01b038251168652848201516003811061170357634e487b7160e01b600052602160045260246000fd5b868601526040918201519186018a905281519081905290840190600090898701905b8083101561174f5783516001600160e01b0319168252928601926001929092019190860190611725565b509785019795505050908201906001016116a0565b50506001600160a01b038a16908801528681036040880152611786818961164b565b9a9950505050505050505050565b60006bffffffffffffffffffffffff8083168181036117b5576117b56115f7565b6001019392505050565b600082516117d1818460208701611627565b9190910192915050565b6020815260006117ee602083018461164b565b9392505050565b81810381811115611808576118086115f7565b92915050565b634e487b7160e01b600052603160045260246000fdfe4c69624469616d6f6e644375743a205f696e6974206164647265737320686173206e6f20636f64654c69624469616d6f6e644375743a204e657720666163657420686173206e6f20636f6465a2646970667358221220fb6ba3580fc6c45bb49e0f8cd2f8936415736f29f73b95ff5f4da4f67ec7b84264736f6c63430008140033c8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c4c69624469616d6f6e644375743a205f696e6974206164647265737320686173206e6f20636f64654c69624469616d6f6e644375743a204164642066616365742063616e277420624c69624469616d6f6e644375743a204e657720666163657420686173206e6f20636f64654c69624469616d6f6e644375743a204e6f2073656c6563746f727320696e2066",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100415760003560e01c80636d4ce63c146100465780639ca33c9e14610066578063e8a3d48514610079575b600080fd5b61004e61008e565b60405161005d93929190611ddc565b60405180910390f35b61004e610074366004611e17565b6101c9565b610081611933565b60405161005d9190611f18565b6060600080600061009d611961565b5050604080516002808252606082018352929350600092909160208301908036833701905050905081516001146100d6576100d6611f32565b816000815181106100e9576100e9611f48565b60200260200101518160008151811061010457610104611f48565b60200260200101906001600160a01b031690816001600160a01b0316815250507f00000000000000000000000000000000000000000000000000000000000000008160018151811061015857610158611f48565b6001600160a01b0390921660209283029190910182015260405183916101a291017f496e697469616c697a65644469616d6f6e64446973747269627574696f6e00008152601e0190565b6040516020818303038152906040526101ba90611f5e565b60009450945094505050909192565b606060008060006101d8611a2f565b505090506000816000815181106101f1576101f1611f48565b602002602001015190506000600867ffffffffffffffff81111561021757610217611e01565b60405190808252806020026020018201604052801561026457816020015b604080516060808201835260008083526020830152918101919091528152602001906001900390816102355790505b5060408051600480825260a082019092529192506000919060208201608080368337019050509050637a0ed62760e01b816000815181106102a7576102a7611f48565b6001600160e01b03199092166020928302919091019091015280517fadfca15e0000000000000000000000000000000000000000000000000000000090829060019081106102f7576102f7611f48565b6001600160e01b03199092166020928302919091019091015280517f52ef6b2c00000000000000000000000000000000000000000000000000000000908290600290811061034757610347611f48565b6001600160e01b03199092166020928302919091019091015280517fcdffacc600000000000000000000000000000000000000000000000000000000908290600390811061039757610397611f48565b6001600160e01b031990921660209283029190910182015260408051606081019091526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016815290810160008152602001828152508260008151811061040757610407611f48565b60209081029190910101526040805160028082526060820190925260009181602001602082028036833701905050905063d3a8018d60e01b8160008151811061045257610452611f48565b6001600160e01b03199092166020928302919091019091015280517f6cbadbfa0000000000000000000000000000000000000000000000000000000090829060019081106104a2576104a2611f48565b6001600160e01b031990921660209283029190910182015260408051606081019091526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016815290810160008152602001828152508360018151811061051257610512611f48565b602090810291909101015260408051601c8082526103a082019092526000918160200160208202803683370190505090506369958ab960e01b8160008151811061055e5761055e611f48565b6001600160e01b03199092166020928302919091019091015280517faee5f34a0000000000000000000000000000000000000000000000000000000090829060019081106105ae576105ae611f48565b6001600160e01b0319909216602092830291909101820152604080516060810190915260238082526105ec926121ac90830139805160209091012090565b816002815181106105ff576105ff611f48565b6001600160e01b03199092166020928302919091018201526040805160608101909152602d80825261063d926121cf90830139805160209091012090565b8160038151811061065057610650611f48565b6001600160e01b031990921660209283029190910182015260408051808201909152601b81527f63726561746547616d6528616464726573732c75696e743235362900000000009101527f07ead9304ed4c506629fd3beab7ecc0f07c2ade3fb42eb798fed46a8e7dacffb816004815181106106ce576106ce611f48565b6001600160e01b03199092166020928302919091019091015280517f3feef58a00000000000000000000000000000000000000000000000000000000908290600590811061071e5761071e611f48565b6001600160e01b03199092166020928302919091019091015280517fefaa55a000000000000000000000000000000000000000000000000000000000908290600690811061076e5761076e611f48565b6001600160e01b03199092166020928302919091019091015280517fcca84a0c0000000000000000000000000000000000000000000000000000000090829060079081106107be576107be611f48565b6001600160e01b03199092166020928302919091019091015280517fe5ed1d5900000000000000000000000000000000000000000000000000000000908290600890811061080e5761080e611f48565b6001600160e01b03199092166020928302919091019091015280517fbc197c8100000000000000000000000000000000000000000000000000000000908290600990811061085e5761085e611f48565b6001600160e01b03199092166020928302919091019091015280517ff23a6e6100000000000000000000000000000000000000000000000000000000908290600a9081106108ae576108ae611f48565b6001600160e01b03199092166020928302919091019091015280517f150b7a0200000000000000000000000000000000000000000000000000000000908290600b9081106108fe576108fe611f48565b6001600160e01b03199092166020928302919091019091015280517f7f4e484900000000000000000000000000000000000000000000000000000000908290600c90811061094e5761094e611f48565b6001600160e01b03199092166020928302919091019091015280517fb55991c000000000000000000000000000000000000000000000000000000000908290600d90811061099e5761099e611f48565b6001600160e01b03199092166020928302919091019091015280517ff72ea46700000000000000000000000000000000000000000000000000000000908290600e9081106109ee576109ee611f48565b6001600160e01b03199092166020928302919091019091015280517f04527d9000000000000000000000000000000000000000000000000000000000908290600f908110610a3e57610a3e611f48565b6001600160e01b03199092166020928302919091019091015280517f9637460e000000000000000000000000000000000000000000000000000000009082906010908110610a8e57610a8e611f48565b6001600160e01b03199092166020928302919091019091015280517f8eed01f8000000000000000000000000000000000000000000000000000000009082906011908110610ade57610ade611f48565b6001600160e01b03199092166020928302919091019091015280517fbfa64036000000000000000000000000000000000000000000000000000000009082906012908110610b2e57610b2e611f48565b6001600160e01b03199092166020928302919091019091015280517fb881cffe000000000000000000000000000000000000000000000000000000009082906013908110610b7e57610b7e611f48565b6001600160e01b03199092166020928302919091019091015280517f4024ba75000000000000000000000000000000000000000000000000000000009082906014908110610bce57610bce611f48565b6001600160e01b03199092166020928302919091019091015280517f9a214b1e000000000000000000000000000000000000000000000000000000009082906015908110610c1e57610c1e611f48565b6001600160e01b03199092166020928302919091019091015280517f460e2049000000000000000000000000000000000000000000000000000000009082906016908110610c6e57610c6e611f48565b6001600160e01b03199092166020928302919091019091015280517f392b749c000000000000000000000000000000000000000000000000000000009082906017908110610cbe57610cbe611f48565b6001600160e01b03199092166020928302919091019091015280517f58759df7000000000000000000000000000000000000000000000000000000009082906018908110610d0e57610d0e611f48565b6001600160e01b03199092166020928302919091019091015280517f8d3b80b3000000000000000000000000000000000000000000000000000000009082906019908110610d5e57610d5e611f48565b6001600160e01b03199092166020928302919091019091015280517fde83804800000000000000000000000000000000000000000000000000000000908290601a908110610dae57610dae611f48565b6001600160e01b03199092166020928302919091019091015280517f3528dff700000000000000000000000000000000000000000000000000000000908290601b908110610dfe57610dfe611f48565b6001600160e01b031990921660209283029190910182015260408051606081019091526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000168152908101600081526020018281525084600281518110610e6e57610e6e611f48565b60209081029190910101526040805160038082526080820190925260009181602001602082028036833701905050905063bbb294f860e01b81600081518110610eb957610eb9611f48565b6001600160e01b03199092166020928302919091019091015280517fbf0f2d7e000000000000000000000000000000000000000000000000000000009082906001908110610f0957610f09611f48565b6001600160e01b03199092166020928302919091019091015280517f8f298b2a000000000000000000000000000000000000000000000000000000009082906002908110610f5957610f59611f48565b6001600160e01b031990921660209283029190910182015260408051606081019091526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000168152908101600081526020018281525085600381518110610fc957610fc9611f48565b602090810291909101015260408051600380825260808201909252600091816020016020820280368337019050509050636a99473560e01b8160008151811061101457611014611f48565b6001600160e01b03199092166020928302919091019091015280517f463bc35500000000000000000000000000000000000000000000000000000000908290600190811061106457611064611f48565b6001600160e01b03199092166020928302919091019091015280517f0c6446d50000000000000000000000000000000000000000000000000000000090829060029081106110b4576110b4611f48565b6001600160e01b031990921660209283029190910182015260408051606081019091526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016815290810160008152602001828152508660048151811061112457611124611f48565b602090810291909101015260408051600880825261012082019092526000918160200160208202803683370190505090506326126d4660e01b8160008151811061117057611170611f48565b6001600160e01b03199092166020928302919091019091015280517f59db5bf70000000000000000000000000000000000000000000000000000000090829060019081106111c0576111c0611f48565b6001600160e01b03199092166020928302919091019091015280517f869dc02100000000000000000000000000000000000000000000000000000000908290600290811061121057611210611f48565b6001600160e01b03199092166020928302919091019091015280517fc94b01da00000000000000000000000000000000000000000000000000000000908290600390811061126057611260611f48565b6001600160e01b03199092166020928302919091019091015280517f865173410000000000000000000000000000000000000000000000000000000090829060049081106112b0576112b0611f48565b6001600160e01b03199092166020928302919091019091015280517f924b5bb100000000000000000000000000000000000000000000000000000000908290600590811061130057611300611f48565b6001600160e01b03199092166020928302919091019091015280517f911f8e1b00000000000000000000000000000000000000000000000000000000908290600690811061135057611350611f48565b6001600160e01b03199092166020928302919091019091015280517f966fb1ea0000000000000000000000000000000000000000000000000000000090829060079081106113a0576113a0611f48565b6001600160e01b031990921660209283029190910182015260408051606081019091526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016815290810160008152602001828152508760058151811061141057611410611f48565b60209081029190910101526040805160028082526060820190925260009181602001602082028036833701905050905063f2fde38b60e01b8160008151811061145b5761145b611f48565b6001600160e01b03199092166020928302919091019091015280517f8da5cb5b0000000000000000000000000000000000000000000000000000000090829060019081106114ab576114ab611f48565b6001600160e01b031990921660209283029190910182015260408051606081019091526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016815290810160008152602001828152508860068151811061151b5761151b611f48565b6020908102919091010152604080516001808252818301909252600091816020016020820280368337019050509050631eea6f8960e01b8160008151811061156557611565611f48565b6001600160e01b031990921660209283029190910182015260408051606081019091526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001681529081016000815260200182815250896007815181106115d5576115d5611f48565b60200260200101819052506115fa8a8a60405180602001604052806000815250611b4b565b604080516009808252610140820190925260009160208201610120803683370190505090508a8160008151811061163357611633611f48565b60200260200101906001600160a01b031690816001600160a01b0316815250508960008151811061166657611666611f48565b6020026020010151600001518160018151811061168557611685611f48565b60200260200101906001600160a01b031690816001600160a01b031681525050896001815181106116b8576116b8611f48565b602002602001015160000151816002815181106116d7576116d7611f48565b60200260200101906001600160a01b031690816001600160a01b0316815250508960028151811061170a5761170a611f48565b6020026020010151600001518160038151811061172957611729611f48565b60200260200101906001600160a01b031690816001600160a01b0316815250508960038151811061175c5761175c611f48565b6020026020010151600001518160048151811061177b5761177b611f48565b60200260200101906001600160a01b031690816001600160a01b031681525050896004815181106117ae576117ae611f48565b602002602001015160000151816005815181106117cd576117cd611f48565b60200260200101906001600160a01b031690816001600160a01b0316815250508960058151811061180057611800611f48565b6020026020010151600001518160068151811061181f5761181f611f48565b60200260200101906001600160a01b031690816001600160a01b0316815250508960068151811061185257611852611f48565b6020026020010151600001518160078151811061187157611871611f48565b60200260200101906001600160a01b031690816001600160a01b031681525050896007815181106118a4576118a4611f48565b602002602001015160000151816008815181106118c3576118c3611f48565b6001600160a01b0392909216602092830291909101909101529f7f00000000000000000000000000000000000000000000000000000000000000009f507f00000000000000000000000000000000000000000000000000000000000000009e509c50505050505050505050505050565b606061193d611c88565b60405160200161194d9190611f85565b604051602081830303815290604052905090565b6040805160018082528183019092526060916000918291829190602080830190803683370190505090507f0000000000000000000000000000000000000000000000000000000000000000816000815181106119bf576119bf611f48565b6001600160a01b039092166020928302919091018201526040518291611a0991017f4469616d6f6e64446973747269627574696f6e00000000000000000000000000815260130190565b604051602081830303815290604052611a2190611f5e565b600093509350935050909192565b60606000806000806000611a41611caf565b825192955090935091508067ffffffffffffffff811115611a6457611a64611e01565b604051908082528060200260200182016040528015611a8d578160200160208202803683370190505b50965060005b81811015611afd576000611abf868381518110611ab257611ab2611f48565b6020026020010151611d0d565b905080898381518110611ad457611ad4611f48565b6001600160a01b039092166020928302919091019091015250611af681611fec565b9050611a93565b50336001600160a01b03167fe3cc25159981d843f19d5a7611997a66ca6e772edd134fb611c7b29aded7bb8a88604051611b379190612014565b60405180910390a250949590949350915050565b600080825111611b6a5760405180602001604052806000815250611be4565b7f000000000000000000000000000000000000000000000000000000000000000082604051602401611b9c9190611f18565b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff166001600160e01b0319909316929092179091525b6040517f1f931c1c0000000000000000000000000000000000000000000000000000000081529091506001600160a01b03851690631f931c1c90611c509086907f0000000000000000000000000000000000000000000000000000000000000000908690600401612027565b600060405180830381600087803b158015611c6a57600080fd5b505af1158015611c7e573d6000803e3d6000fd5b5050505050505050565b6060611c9f60408051602081019091526000815290565b60405160200161194d9190612144565b60606000806000611cbe611961565b5090957f000000000000000000000000000000000000000000000000000000000000000095507f0000000000000000000000000000000000000000000000000000000000000000945092505050565b6000763d602d80600a3d3981f3363d3d373d3d3d363d730000008260601b60e81c176000526e5af43d82803e903d91602b57fd5bf38260781b17602052603760096000f090506001600160a01b038116611d93576040517fc2f868f400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b919050565b600081518084526020808501945080840160005b83811015611dd15781516001600160a01b031687529582019590820190600101611dac565b509495945050505050565b606081526000611def6060830186611d98565b60208301949094525060400152919050565b634e487b7160e01b600052604160045260246000fd5b600060208284031215611e2957600080fd5b813567ffffffffffffffff80821115611e4157600080fd5b818401915084601f830112611e5557600080fd5b813581811115611e6757611e67611e01565b604051601f8201601f19908116603f01168101908382118183101715611e8f57611e8f611e01565b81604052828152876020848701011115611ea857600080fd5b826020860160208301376000928101602001929092525095945050505050565b60005b83811015611ee3578181015183820152602001611ecb565b50506000910152565b60008151808452611f04816020860160208601611ec8565b601f01601f19169290920160200192915050565b602081526000611f2b6020830184611eec565b9392505050565b634e487b7160e01b600052600160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b80516020808301519190811015611f7f576000198160200360031b1b821691505b50919050565b60008251611f97818460208701611ec8565b7f3b000000000000000000000000000000000000000000000000000000000000009201918252507f4172677561626c65566f74696e67546f75726e616d656e7400000000000000006001820152601901919050565b6000600019820361200d57634e487b7160e01b600052601160045260246000fd5b5060010190565b602081526000611f2b6020830184611d98565b60006060808301818452808751808352608092508286019150828160051b8701016020808b0160005b84811015612114577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff808a850301865281518885016001600160a01b03825116865284820151600381106120b357634e487b7160e01b600052602160045260246000fd5b868601526040918201519186018a905281519081905290840190600090898701905b808310156120ff5783516001600160e01b03191682529286019260019290920191908601906120d5565b50978501979550505090820190600101612050565b50506001600160a01b038a169088015286810360408801526121368189611eec565b9a9950505050505050505050565b60008251612156818460208701611ec8565b7f3b000000000000000000000000000000000000000000000000000000000000009201918252507f496e697469616c697a65644469616d6f6e64446973747269627574696f6e00006001820152601f0191905056fe63726561746547616d6528616464726573732c75696e743235362c75696e743235362963726561746547616d6528616464726573732c75696e743235362c75696e743235362c616464726573735b5d29a2646970667358221220532dcaeb52c1f08b316968efb199d6295c21b7b76fe14f92c6054f65e8c6851264736f6c63430008140033",
  "devdoc": {
    "author": "Peeramid Labs, 2024",
    "details": "It is expected to be used ONLY by the Distributor contract.",
    "errors": {
      "ERC1167FailedCreateClone()": [
        {
          "details": "A clone instance deployment failed."
        }
      ]
    },
    "events": {
      "Distributed(address,address[])": {
        "params": {
          "distributor": "The address of the entity that performed the distribution.",
          "instances": "An array of addresses that were produced."
        }
      }
    },
    "kind": "dev",
    "methods": {
      "constructor": {
        "details": "Constructor for the ArguableVotingTournament contract. Note Initializer function will be added as a regular facet to the Diamond Proxy, Since it is expected that initialization is done by distributor contract, the initializer will not be run, hence it is up for distributor to remove this facet upon succesfull initialization."
      },
      "get()": {
        "returns": {
          "_0": "An array of addresses that are used for instantiation.",
          "name": "The name of the distribution.",
          "version": "The version of the distribution."
        }
      },
      "instantiate(bytes)": {
        "details": "see Ethereum Distribution System IDistribute for interface specification.",
        "returns": {
          "_1": "distributionName: bytes32 encoded name to be used in EIP712 signing flow",
          "_2": "distributionVersion: uint256 encoded distribution version. Can be parsed to eip712 signature with EDS LibSemver",
          "instances": "Array[9]: [diamond proxy, 8x diamond facets..]"
        }
      }
    },
    "title": "ArguableVotingTournament Distribution",
    "version": 1
  },
  "userdoc": {
    "events": {
      "Distributed(address,address[])": {
        "notice": "Emitted when a distribution occurs."
      }
    },
    "kind": "user",
    "methods": {
      "get()": {
        "notice": "Retrieves the current distribution sources."
      }
    },
    "notice": "This contract implements a diamond distribution for Ethereum Distribution System. It is reponsible to create new instance of ArguableVotingTournament.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}